@InProceedings{Wadler2009,
  author    = {Wadler, Philip and Findler, Robert Bruce},
  booktitle = {Proceedings of the 18th European Symposium on Programming Languages and Systems (ESOP 2009)},
  date      = {2009},
  title     = {Well-Typed Programs Can't Be Blamed},
  editor    = {Giuseppe Castagna},
  pages     = {1--16},
  publisher = {Springer-Verlag},
  series    = {Lecture Notes in Computer Science},
  crossref  = {esop2009},
  priority  = {prio3},
}

@Book{Barendregt1985,
  author    = {Barendregt, H.},
  date      = {1985},
  title     = {The Lambda Calculus: Its Syntax and Semantics. Revised Edition.},
  number    = {103},
  publisher = {North Holland},
  series    = {Studies in Logics and the Foundation of Mathematics},
  abstract  = {This book is the lambda-calculus bible. It contains detailed discussions on syntax, semantics and pragmatics along with many theorems and proofs.},
  file      = {Barendregt1985.pdf:Barendregt1985 - The Lambda Calculus_ Its Syntax and Semantics. Revised Edition..pdf:PDF},
  groups    = {Lambda Calculus, meven:5, Computer Science Textbooks},
  priority  = {prio3},
}

@Book{Barendregt2013,
  author    = {Barendregt, Henk and Dekkers, Wil and Statman, Richard},
  date      = {2013},
  title     = {Lambda Calculus with Types},
  publisher = {Cambridge University Press},
  file      = {Barendregt2013.pdf:Barendregt2013 - Lambda Calculus with Types.pdf:PDF},
  groups    = {Lambda Calculus, meven:5, Computer Science Textbooks},
  priority  = {prio3},
}

@InProceedings{Boulier2017,
  author      = {Boulier, Simon and P{\'e}drot, Pierre-Marie and Tabareau, Nicolas},
  booktitle   = {{Certified Programs and Proofs (CPP 2017)}},
  date        = {2017-01},
  title       = {{The next 700 syntactical models of type theory}},
  doi         = {10.1145/3018610.3018620},
  location    = {Paris, France},
  pages       = {182-194},
  url         = {https://hal.inria.fr/hal-01445835},
  file        = {Boulier2017.pdf:Boulier2017 - The Next 700 Syntactical Models of Type Theory.pdf:PDF;main.pdf:https\://hal.inria.fr/hal-01445835/file/main.pdf:PDF},
  groups      = {meven:3, Syntactical Models},
  hal_id      = {hal-01445835},
  hal_version = {v1},
  keywords    = {Program translation ; Dependent type theory},
  priority    = {prio3},
}

@Article{Castagna2019,
  author       = {Giuseppe Castagna and Victor Lanvin and Tommaso Petrucciani and Jeremy G. Siek},
  date         = {2019-01},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {Gradual Typing: a New Perspective},
  note         = {To appear},
  number       = {POPL\,'19},
  volume       = {3, Article 16},
  file         = {Castagna2019.pdf:Castagna2019 - Gradual Typing_ a New Perspective.pdf:PDF},
  groups       = {Gradual Typing, meven:3},
  priority     = {prio3},
}

@Article{Dagand2018,
  author       = {Pierre-{\'E}variste Dagand and Nicolas Tabareau and {\'E}ric Tanter},
  date         = {2018},
  journaltitle = {Journal of Functional Programming},
  title        = {Foundations of Dependent Interoperability},
  volume       = {28},
  file         = {Dagand2018.pdf:Dagand2018 - Foundations of Dependent Interoperability.pdf:PDF},
  groups       = {Gradual Typing, meven:3, Proof Assistants},
  priority     = {prio3},
  publisher    = {Cambridge University Press},
  urldoi       = {http://dx.doi.org/10.1017/S0956796818000011},
  urlpdf       = {http://pleiad.dcc.uchile.cl/papers/2018/dagandAl-jfp2018.pdf},
  users        = {etanter},
}

@InProceedings{Garcia2016,
  author    = {Ronald Garcia and Alison M. Clark and {\'E}ric Tanter},
  booktitle = {Proceedings of the 43rd ACM Symposium on Principles of Programming Languages (POPL 2016)},
  date      = {2016-01},
  title     = {Abstracting Gradual Typing},
  location  = {St Petersburg, FL, USA},
  pages     = {429--442},
  publisher = {ACM Press},
  file      = {Garcia2016.pdf:Garcia2016 - Abstracting Gradual Typing.pdf:PDF},
  groups    = {Gradual Typing, meven:4},
  priority  = {prio3},
  urldoi    = {http://dx.doi.org/10.1145/2837614.2837670},
  urlpdf    = {http://pleiad.dcc.uchile.cl/papers/2016/garciaAl-popl2016.pdf},
  users     = {etanter},
}

@Article{Geuvers1991,
  author       = {Geuvers, Herman and Nederhof, Mark-Jan},
  date         = {1991},
  journaltitle = {Journal of Functional Programming},
  title        = {Modular proof of strong normalization for the calculus of constructions},
  doi          = {10.1017/S0956796800020037},
  number       = {2},
  pages        = {155-189},
  volume       = {1},
  abstract     = {Proof of subject reduction of CoC},
  file         = {Geuvers1991.pdf:Geuvers1991 - Modular Proof of Strong Normalization for the Calculus of Constructions.pdf:PDF},
  groups       = {CIC, meven:4, Pure Type Systems, Conversion, Normalization, Bidirectional Typing},
  priority     = {prio2},
  publisher    = {Cambridge University Press},
}

@Article{Gilbert2019,
  author              = {Gilbert, Ga{\"e}tan and Cockx, Jesper and Sozeau, Matthieu and Tabareau, Nicolas},
  date                = {2019-01},
  journaltitle        = {Proceedings of the ACM on Programming Languages},
  title               = {Definitional Proof-Irrelevance without K},
  doi                 = {10.1145/329031610.1145/3290316},
  number              = {POPL},
  pages               = {1-28},
  series              = {POPL'19},
  url                 = {https://hal.inria.fr/hal-01859964},
  volume              = {3},
  file                = {Gilbert2019.pdf:Gilbert2019 - Definitional Proof Irrelevance without K.pdf:PDF;main_popl.pdf:https\://hal.inria.fr/hal-01859964/file/main_popl.pdf:PDF},
  groups              = {meven:2, Irrelevance},
  hal_id              = {hal-01859964},
  hal_local_reference = {ACL+},
  hal_version         = {v2},
  priority            = {prio3},
  publisher           = {{ACM}},
}

@InProceedings{Hofmann1996,
  author    = {Martin Hofmann and Thomas Streicher},
  booktitle = {In Venice Festschrift},
  date      = {1996},
  title     = {The Groupoid Interpretation of Type Theory},
  pages     = {83--111},
  publisher = {Oxford University Press},
  file      = {:Hofmann1996 - The Groupoid Interpretation of Type Theory.ps:PostScript},
  groups    = {CIC, HoTT, meven:2, Models of TT},
  priority  = {prio2},
}

@InProceedings{Lehmann2017,
  author    = {Nico Lehmann and {\'E}ric Tanter},
  booktitle = {Proceedings of the 44th {ACM SIGPLAN-SIGACT} Symposium on Principles of Programming Languages (POPL 2017)},
  date      = {2017-01},
  title     = {Gradual Refinement Types},
  location  = {Paris, France},
  pages     = {775--788},
  publisher = {ACM Press},
  file      = {Extended Version:Lehmann2017 - Gradual Refinement Types.pdf:PDF;Paper Version:Lehmann2017.pdf:PDF},
  groups    = {Gradual Typing, meven:3},
  priority  = {prio3},
  urldoi    = {http://dx.doi.org/10.1145/3009837.3009856},
  urlpdf    = {http://pleiad.dcc.uchile.cl/papers/2017/lehmannTanter-popl2017.pdf},
  users     = {etanter , nlehmann},
}

@InProceedings{Levy1999,
  author    = {Levy, Paul Blain},
  booktitle = {Typed Lambda Calculi and Applications},
  date      = {1999},
  title     = {Call-by-Push-Value: A Subsuming Paradigm},
  editor    = {Girard, Jean-Yves},
  pages     = {228--243},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Call-by-push-value is a new paradigm that subsumes the call-by-name and call-by-value paradigms, in the following sense: both operational and denotational semantics for those paradigms can be seen as arising, via translations that we will provide, from similar semantics for call-by-observable.},
  file      = {Levy1999.pdf:Levy1999 - Call by Push Value_ a Subsuming Paradigm.pdf:PDF},
  groups    = {Effects, meven:4, Semantics of PL},
  priority  = {prio3},
}

@Book{MacLane2013,
  author    = {Mac Lane, Saunders},
  date      = {2013},
  title     = {Categories for the Working Mathematician},
  publisher = {Springer Science \& Business Media},
  volume    = {5},
  file      = {:MacLane2013 - Categories for the Working Mathematician.pdf:PDF},
  groups    = {Categories, meven:5, Mathematics Textbooks, Category Theory},
  priority  = {prio3},
}

@Book{MartinLoef1984,
  author    = {Martin-Löf, Per and Sambin, Giovanni},
  date      = {1984},
  title     = {Intuitionistic Type Theory},
  number    = {1},
  publisher = {{Napoli: Bibliopolis}},
  series    = {Studies in Proof Theory},
  file      = {Martin-Loef1984.djvu:MartinLoef1984 - Intuitionistic Type Theory.djvu:Djvu},
  groups    = {meven:5, MLTT, History},
  priority  = {prio3},
}

@Article{New2019,
  author       = {New, Max S. and Licata, Daniel R. and Ahmed, Amal},
  date         = {2019-01},
  journaltitle = {Proceeding of the ACM on Programming Languages},
  title        = {Gradual Type Theory},
  doi          = {10.1145/3290328},
  number       = {POPL},
  volume       = {3},
  articleno    = {15},
  file         = {Extended Version:New2019 - Gradual Type Theory.pdf:PDF;Paper Version:New2019.pdf:PDF},
  groups       = {Gradual Typing, meven:2},
  issue_date   = {January 2019},
  keywords     = {call-by-push-value, gradual typing, graduality},
  priority     = {prio3},
  publisher    = {ACM},
}

@Book{Nordstroem1990,
  author       = {Nordström, Bengt and Petersson, Kent and Smith, Jan M.},
  date         = {1990},
  title        = {Programming in Martin-Löf's Type Theory},
  doi          = {10.1016/0167-6423(91)90006-J},
  pages        = {202-203},
  publisher    = {Oxford University Press},
  file         = {Nordstroem1990.pdf:Nordstroem1990 - Programming in Martin Löf's Type Theory.pdf:PDF},
  groups       = {meven:5, MLTT},
  journaltitle = {Science of Computer Programming},
  priority     = {prio3},
}

@Article{Pedrot2020,
  author       = {P\'{e}drot, Pierre-Marie and Tabareau, Nicolas},
  date         = {2020},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {The Fire Triangle: How to Mix Substitution, Dependent Elimination, and Effects},
  doi          = {10.1145/3371126},
  number       = {POPL},
  volume       = {4},
  file         = {Pedrot2019a.pdf:Pedrot2020 - The Fire Triangle_ How to Mix Substitution, Dependent Elimination, and Effects.pdf:PDF},
  groups       = {Effects, CIC, meven:3, Syntactical Models},
  issue_date   = {January 2020},
  location     = {New York, NY, USA},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@InProceedings{Pedrot2018,
  author    = {P{\'e}drot, Pierre-Marie and Tabareau, Nicolas},
  booktitle = {ESOP 2018 - 27th European Symposium on Programming},
  date      = {2018},
  title     = {Failure is Not an Option An Exceptional Type Theory},
  doi       = {10.1007/978-3-319-89884-1\_9},
  location  = {Thessaloniki, Greece},
  pages     = {245-271},
  publisher = {Springer},
  series    = {LNCS},
  volume    = {10801},
  file      = {Pedrot2018.pdf:Pedrot2018 - Failure Is Not an Option an Exceptional Type Theory.pdf:PDF},
  groups    = {Effects, CIC, meven:3, Syntactical Models},
  priority  = {prio3},
}

@InProceedings{Pedrot2017,
  author    = {P{\'e}drot, Pierre-Marie and Tabareau, Nicolas},
  booktitle = {2017 32nd Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)},
  date      = {2017},
  title     = {An Effectful Way to Eliminate Addiction to Dependence},
  doi       = {10.1109/LICS.2017.8005113},
  url       = {https://hal.inria.fr/hal-01441829},
  file      = {EffectfulDependence.pdf:Pedrot2017 - An Effectful Way to Eliminate Addiction to Dependence.pdf:PDF},
  groups    = {Effects, meven:3},
  priority  = {prio3},
}

@InCollection{PaulinMohring2015,
  author    = {Paulin-Mohring, Christine},
  booktitle = {All about Proofs, Proofs for All},
  date      = {2015},
  title     = {Introduction to the Calculus of Inductive Constructions},
  editor    = {Bruno Woltzenlogel Paleo and David Delahaye},
  publisher = {College Publications},
  series    = {Studies in Logic (Mathematical logic and foundations)},
  volume    = {55},
  file      = {Paulin-Mohring2015.pdf:PaulinMohring2015 - Introduction to the Calculus of Inductive Constructions.pdf:PDF},
  groups    = {CIC, meven:5},
  keywords  = {Coq proof assistant ; Calculus of Inductive Constructions},
  priority  = {prio3},
}

@Book{Pierce2002,
  author    = {Benjamin C. Pierce},
  date      = {2002},
  title     = {Types and Programming Languages},
  publisher = {MIT Press},
  series    = {Mit Press},
  file      = {Pierce2002.pdf:Pierce2002 - Types and Programming Languages.pdf:PDF},
  groups    = {meven:5, Computer Science Textbooks},
  priority  = {prio3},
}

@InProceedings{Siek2006,
  author    = {Jeremy G. Siek and Walid Taha},
  booktitle = {In Scheme and Functional Programming Workshop},
  date      = {2006},
  title     = {Gradual Typing for Functional Languages},
  pages     = {81--92},
  file      = {:Siek2006 - Gradual Typing for Functional Languages.pdf:PDF},
  groups    = {Gradual Typing, meven:3},
  priority  = {prio3},
}

@InProceedings{Siek2015,
  author     = {Jeremy G. Siek and Michael M. Vitousek and Matteo Cimini and John Tang Boyland},
  booktitle  = {1st Summit on Advances in Programming Languages (SNAPL 2015)},
  date       = {2015},
  title      = {Refined Criteria for Gradual Typing},
  doi        = {10.4230/LIPIcs.SNAPL.2015.274},
  editor     = {Thomas Ball and Rastislav Bodik and Shriram Krishnamurthi and Benjamin S. Lerner and Greg Morrisett},
  pages      = {274--293},
  publisher  = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  series     = {Leibniz International Proceedings in Informatics (LIPIcs)},
  volume     = {32},
  annotation = {Keywords: gradual typing, type systems, semantics, dynamic languages},
  file       = {Siek2015.pdf:Siek2015 - Refined Criteria for Gradual Typing.pdf:PDF},
  groups     = {Gradual Typing, meven:3},
  priority   = {prio3},
}

@PhdThesis{Siles2010,
  author      = {Siles, Vincent},
  date        = {2010},
  institution = {{\'E}cole Polytechnique},
  title       = {Investigation on the Typing of Equality in Type Systems},
  file        = {Siles2010.pdf:Siles2010 - Investigation on the Typing of Equality in Type Systems.pdf:PDF},
  groups      = {CIC, meven:5, Conversion},
  priority    = {prio3},
}

@Article{Tabareau2018,
  author              = {Tabareau, Nicolas and Tanter, {\'E}ric and Sozeau, Matthieu},
  date                = {2018-09},
  journaltitle        = {Proceedings of the ACM on Programming Languages},
  title               = {{Equivalences for Free}},
  doi                 = {10.1145/3234615},
  number              = {ICFP},
  pages               = {1-29},
  series              = {ICFP'18},
  url                 = {https://hal.inria.fr/hal-01559073},
  volume              = {2},
  file                = {Tabareau2018.pdf:Tabareau2018 - Equivalences for Free.pdf:PDF;main_icfp.pdf:https\://hal.inria.fr/hal-01559073/file/main_icfp.pdf:PDF},
  groups              = {CIC, HoTT, meven:3},
  hal_id              = {hal-01559073},
  hal_local_reference = {ACL+},
  hal_version         = {v5},
  keywords            = {Coq ; Type theory ; Homotopy Type Theory ; Parametricity ; Type structures ; Program reasoning},
  priority            = {prio3},
  publisher           = {{ACM}},
}

@InProceedings{Tanter2015,
  author    = {{\'E}ric Tanter and Nicolas Tabareau},
  booktitle = {Proceedings of the 11th {ACM} Dynamic Languages Symposium (DLS 2015)},
  date      = {2015-10},
  title     = {Gradual Certified Programming in {Coq}},
  location  = {Pittsburgh, PA, USA},
  pages     = {26--40},
  publisher = {ACM Press},
  file      = {Tanter2015.pdf:Tanter2015 - Gradual Certified Programming in Coq.pdf:PDF},
  groups    = {Gradual Typing, meven:4},
  priority  = {prio3},
  urldoi    = {http://dx.doi.org/10.1145/2816707.2816710},
  urlpdf    = {http://pleiad.dcc.uchile.cl/papers/2015/tanterTabareau-dls2015.pdf},
  users     = {etanter},
}

@Article{Toro2019,
  author       = {Toro, Mat\'{\i}as and Labrada, Elizabeth and Tanter, \'{E}ric},
  date         = {2019-01},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {Gradual Parametricity, Revisited},
  doi          = {10.1145/3290330},
  number       = {POPL},
  volume       = {3},
  articleno    = {17},
  file         = {Extended Version:Toro2019 - Gradual Parametricity, Revisited.pdf:PDF;Paper Version:Toro2019.pdf:PDF},
  groups       = {Gradual Typing, meven:4},
  keywords     = {Gradual typing, parametricity, polymorphism},
  numpages     = {30},
  priority     = {prio3},
  publisher    = {ACM},
}

@Article{Ziliani2017,
  author       = {Ziliani, Beta and Sozeau, Matthieu},
  date         = {2017},
  journaltitle = {Journal of Functional Programming},
  title        = {A comprehensible guide to a new unifier for CIC including universe polymorphism and overloading},
  doi          = {10.1017/S0956796817000028},
  pages        = {e10},
  volume       = {27},
  file         = {Ziliani2017.pdf:Ziliani2017 - A Comprehensible Guide to a New Unifier for CIC Including Universe Polymorphism and Overloading.pdf:PDF},
  groups       = {meven:3, Proof Assistants},
  priority     = {prio3},
  publisher    = {Cambridge University Press},
}

@TechReport{Veldman2000,
  author      = {Wim Veldman},
  date        = {2000},
  institution = {University of Nijmegen},
  title       = {{Understanding and Using Brouwer's Continuity Principle}},
  type        = {techreport},
  file        = {Veldman2000.pdf:Veldman2000 - Understanding and Using Brouwer's Continuity Principle.pdf:PDF},
  groups      = {Constructivism, meven:3},
  priority    = {prio3},
}

@Article{Asperti2012,
  author       = {Asperti, Andrea and Ricciotti, Wilmer and Coen, Claudio Sacerdoti and Tassi, Enrico},
  date         = {2012-03},
  journaltitle = {Logical Methods in Computer Science},
  title        = {{A Bi-Directional Refinement Algorithm for the Calculus of (Co)Inductive Constructions}},
  doi          = {10.2168/LMCS-8(1:18)2012},
  url          = {https://lmcs.episciences.org/1044},
  volume       = {{Volume 8, Issue 1}},
  file         = {Asperti2012.pdf:Asperti2012 - A Bi Directional Refinement Algorithm for the Calculus of (Co)Inductive Constructions.pdf:PDF},
  groups       = {CIC, meven:3, Proof Assistants, Bidirectional Typing},
  keywords     = {Computer Science - Logic in Computer Science ; Computer Science - Artificial Intelligence ; D.3.1, F.3.0},
  priority     = {prio3},
}

@PhdThesis{SacerdotiCoen2004,
  author      = {Claudio {Sacerdoti Coen}},
  date        = {2004-03},
  institution = {University of Bologna (Italy). Department of Computer Science},
  title       = {Knowledge Management of Formal Mathematics and Interactive Theorem Proving (Ph.D. Thesis)},
  file        = {SacerdotiCoen2004.ps:SacerdotiCoen2004 - Knowledge Management of Formal Mathematics and Interactive Theorem Proving (Ph.D. Thesis).ps:PostScript},
  groups      = {Proof Assistants},
  number      = {UBLCS-2004-5},
  priority    = {prio3},
}

@InProceedings{Garcia2015,
  author    = {Garcia, Ronald and Cimini, Matteo},
  booktitle = {ACM SIGPLAN Notices},
  date      = {2015-05},
  title     = {Principal Type Schemes for Gradual Programs},
  doi       = {10.1145/2676726.2676992},
  pages     = {303-315},
  file      = {Garcia2015.pdf:Garcia2015 - Principal Type Schemes for Gradual Programs.pdf:PDF},
  groups    = {Gradual Typing, meven:3},
  priority  = {prio3},
}

@Article{Eremondi2019,
  author       = {Joseph Eremondi and {\'E}ric Tanter and Ronald Garcia},
  date         = {2019-08},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {Approximate Normalization for Gradual Dependent Types},
  number       = {ICFP},
  volume       = {3},
  file         = {:Eremondi2019 - Approximate Normalization for Gradual Dependent Types.pdf:PDF},
  groups       = {Gradual Typing, meven:3},
  priority     = {prio3},
  publisher    = {ACM Press},
  users        = {etanter},
}

@PhdThesis{Boulier2018,
  author      = {Boulier, S.},
  date        = {2018},
  institution = {\'Ecole Mines-Telecom Atlantique},
  title       = {Extending Type Theory with Syntactical Models},
  file        = {Boulier2018.pdf:Boulier2018 - Extending Type Theory with Syntactical Models.pdf:PDF},
  groups      = {meven:3, Syntactical Models, MLTT},
  priority    = {prio3},
}

@InProceedings{Altenkirch1999,
  author    = {Altenkirch, Thorsten},
  booktitle = {Proceedings - Symposium on Logic in Computer Science},
  date      = {1999-02},
  title     = {Extensional equality in intensional type theory},
  doi       = {10.1109/LICS.1999.782636},
  isbn      = {0-7695-0158-3},
  pages     = {412-420},
  file      = {Altenkirch1999.pdf:Altenkirch1999 - Extensional Equality in Intensional Type Theory.pdf:PDF},
  groups    = {CIC, meven:3, HoTT, Models of TT},
  priority  = {prio3},
}

@InProceedings{Brady2004,
  author    = {Brady, Edwin and McBride, Conor and McKinna, James},
  booktitle = {Types for Proofs and Programs},
  date      = {2004},
  title     = {Inductive Families Need Not Store Their Indices},
  editor    = {Berardi, Stefano and Coppo, Mario and Damiani, Ferruccio},
  isbn      = {978-3-540-24849-1},
  location  = {Berlin, Heidelberg},
  pages     = {115--129},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We consider the problem of efficient representation of dependently typed data. In particular, we consider a language TT based on Dybjer's notion of inductive families [10] and reanalyse their general form with a view to optimising the storage associated with their use. We introduce an execution language, ExTT, which allows the commenting out of computationally irrelevant subterms and show how to use properties of elimination rules to elide constructor arguments and tags in ExTT. We further show how some types can be collapsed entirely at run-time. Several examples are given, including a representation of the simply typed $\lambda$-calculus for which our analysis yields an 80{\%} reduction in run-time storage requirements.},
  file      = {Brady2004.pdf:Brady2004 - Inductive Families Need Not Store Their Indices.pdf:PDF},
  groups    = {meven:2, Inductive Types},
  priority  = {prio3},
}

@Article{Coquand1988,
  author       = {Thierry Coquand and Gérard Huet},
  date         = {1988},
  journaltitle = {Information and Computation},
  title        = {The calculus of constructions},
  doi          = {10.1016/0890-5401(88)90005-3},
  issn         = {0890-5401},
  number       = {2},
  pages        = {95-120},
  volume       = {76},
  file         = {Coquand1988.pdf:Coquand1988 - The Calculus of Constructions.pdf:PDF},
  groups       = {CIC, meven:5, History},
  priority     = {prio3},
}

@InProceedings{PaulinMohring1993,
  author      = {C. Paulin-Mohring},
  booktitle   = {Proceedings of the conference Typed Lambda Calculi and Applications},
  date        = {1993},
  title       = {{Inductive Definitions in the System {Coq} - Rules and Properties}},
  editor      = {M. Bezem and J.-F. Groote},
  note        = {LIP research report 92-49},
  number      = {664},
  series      = {Lecture Notes in Computer Science},
  file        = {Paulin-Mohring1993.pdf:PaulinMohring1993 - Inductive Definitions in the System Coq Rules and Properties.pdf:PDF},
  groups      = {CIC, meven:5, Inductive Types, History},
  institution = {LIP-ENS Lyon},
  priority    = {prio3},
  type        = {research report},
}

@Article{Barendregt1991,
  author       = {Barendregt, Henk},
  date         = {1991-04},
  journaltitle = {Journal of Functional Programming},
  title        = {An Introduction to Generalized Type Systems},
  doi          = {10.1017/S0956796800020025},
  pages        = {125-154},
  volume       = {1},
  file         = {Barendregt1991.pdf:Barendregt1991 - An Introduction to Generalized Type Systems.pdf:PDF},
  groups       = {Lambda Calculus, meven:4, Pure Type Systems, History},
  priority     = {prio3},
}

@InProceedings{Pedrot2019,
  author    = {P{\'e}drot, Pierre-Marie and Tabareau, Nicolas and Fehrmann, Hans Jacob and Tanter, {\'E}ric},
  booktitle = {{ICFP 2019 - 24th ACM SIGPLAN International Conference on Functional Programming}},
  date      = {2019-08},
  title     = {{A Reasonably Exceptional Type Theory}},
  doi       = {10.1145/3341712},
  location  = {Berlin, Germany},
  publisher = {{ACM}},
  file      = {Pedrot2019.pdf:Pedrot2019 - A Reasonably Exceptional Type Theory.pdf:PDF;icfp19main-p108-p-48a52d2-41764-final.pdf:https\://hal.inria.fr/hal-02189128/file/icfp19main-p108-p-48a52d2-41764-final.pdf:PDF},
  groups    = {CIC, Effects, meven:3, Syntactical Models},
  priority  = {prio3},
}

@Article{Dybjer2000,
  author       = {Dybjer, Peter},
  date         = {2000-06},
  journaltitle = {Journal of Symbolic Logic},
  title        = {A General Formulation of Simultaneous Inductive-Recursive Definitions in Type Theory},
  doi          = {10.2307/2586554},
  volume       = {65},
  file         = {Dybjer2000.pdf:Dybjer2000 - A General Formulation of Simultaneous Inductive Recursive Definitions in Type Theory.pdf:PDF},
  groups       = {meven:2, Inductive Types, Models of TT, MLTT},
  priority     = {prio3},
}

@Manual{CDT2019,
  author   = {{The Coq Development Team}},
  date     = {2019-01},
  title    = {The Coq Proof Assistant, version 8.11.0},
  doi      = {10.5281/zenodo.2554024},
  groups   = {meven:5, Proof Assistants, Manuals},
  priority = {prio3},
}

@InProceedings{Anand2018,
  author    = {Anand, Abhishek and Boulier, Simon and Cohen, Cyril and Sozeau, Matthieu and Tabareau, Nicolas},
  booktitle = {{ITP 2018 - 9th Conference on Interactive Theorem Proving}},
  date      = {2018-07},
  title     = {{Towards Certified Meta-Programming with Typed Template-Coq}},
  doi       = {10.1007/978-3-319-94821-8\_2},
  location  = {Oxford, United Kingdom},
  pages     = {20-39},
  publisher = {{Springer}},
  series    = {LNCS},
  volume    = {10895},
  file      = {Anand2018.pdf:Anand2018 - Towards Certified Meta Programming with Typed Template Coq.pdf:PDF;paper_39.pdf:https\://hal.archives-ouvertes.fr/hal-01809681/file/paper_39.pdf:PDF},
  groups    = {meven:1, Proof Assistants, MetaCoq},
  priority  = {prio3},
}

@InCollection{Dowek2001,
  author    = {Gilles Dowek},
  booktitle = {Handbook of Automated Reasoning},
  date      = {2001},
  title     = {Chapter 16 - Higher-Order Unification and Matching},
  doi       = {10.1016/B978-044450813-3/50018-7},
  editor    = {Alan Robinson and Andrei Voronkov},
  pages     = {1009-1062},
  publisher = {North-Holland},
  series    = {Handbook of Automated Reasoning},
  groups    = {meven:5, Conversion},
  priority  = {prio3},
}

@TechReport{Rossum2014,
  author      = {van Rossum, Guido and Lehtosalo, Jukka and Langa, Łukasz},
  date        = {2014},
  institution = {The Python Software Foundation},
  title       = {PEP 484 – Type Hints},
  url         = {https://www.python.org/dev/peps/pep-0484/},
  groups      = {Gradual Typing, meven:5},
  priority    = {prio3},
}

@InProceedings{Siek2008,
  author    = {Siek, Jeremy G. and Vachharajani, Manish},
  booktitle = {Proceedings of the 2008 Symposium on Dynamic Languages},
  date      = {2008},
  title     = {Gradual Typing with Unification-based Inference},
  doi       = {10.1145/1408681.1408688},
  series    = {DLS '08},
  file      = {Siek2008.pdf:Siek2008 - Gradual Typing with Unification Based Inference.pdf:PDF},
  groups    = {meven:2, Gradual Typing},
  priority  = {prio3},
}

@Article{Kaposi2020,
  author       = {Kaposi, Ambrus and Kovács, András},
  date         = {2020-02},
  journaltitle = {{Logical Methods in Computer Science}},
  title        = {{Signatures and Induction Principles for Higher Inductive-Inductive Types}},
  doi          = {10.23638/LMCS-16(1:10)2020},
  url          = {https://lmcs.episciences.org/6100},
  volume       = {Volume 16, Issue 1},
  groups       = {Inductive Types},
  keywords     = {Computer Science - Logic in Computer Science},
  priority     = {prio3},
}

@InProceedings{Bernardy2011,
  author    = {Bernardy, Jean-Philippe and Lasson, Marc},
  booktitle = {Foundations of Software Science and Computational Structures},
  date      = {2011},
  title     = {Realizability and Parametricity in Pure Type Systems},
  editor    = {Hofmann, Martin},
  location  = {Berlin, Heidelberg},
  pages     = {108--122},
  publisher = {Springer Berlin Heidelberg},
  file      = {Bernardy2011.pdf:Bernardy2011 - Realizability and Parametricity in Pure Type Systems.pdf:PDF},
  groups    = {meven:3, Syntactical Models, Models of TT},
  priority  = {prio3},
}

@Eprint{Shulman2018,
  author      = {Michael Shulman},
  date        = {2018},
  title       = {Linear logic for constructive mathematics},
  note        = {Linear logic and Chu construction for constructive mathematics},
  url         = {https://arxiv.org/pdf/1805.07518.pdf},
  eprint      = {1805.07518},
  eprintclass = {math.LO},
  eprinttype  = {arXiv},
  groups      = {meven:3, Linear Logic, Constructivism},
  priority    = {prio3},
}

@InProceedings{Altenkirch2019,
  author    = {Altenkirch, Thorsten and Boulier, Simon and Kaposi, Ambrus and Tabareau, Nicolas},
  booktitle = {{MPC 2019 - 13th International Conference on Mathematics of Program Construction}},
  date      = {2019-10},
  title     = {{Setoid type theory - a syntactic translation}},
  doi       = {10.1007/978-3-030-33636-3\_7},
  pages     = {155-196},
  publisher = {{Springer}},
  series    = {LNCS},
  volume    = {11825},
  file      = {Altenkirch2019.pdf:Altenkirch2019 - Setoid Type Theory a Syntactic Translation.pdf:PDF;mpc2019.pdf:https\://hal.inria.fr/hal-02281225/file/mpc2019.pdf:PDF},
  groups    = {HoTT, meven:3, Syntactical Models, Irrelevance},
  priority  = {prio3},
}

@Article{Appel1977a,
  author       = {Appel, K. and Haken, W. and Koch, J.},
  date         = {1977-09},
  journaltitle = {Illinois Journal of Mathematics},
  title        = {Every planar map is four colorable. Part II: Reducibility},
  doi          = {10.1215/ijm/1256049012},
  number       = {3},
  pages        = {491--567},
  volume       = {21},
  file         = {Appel1977a.pdf:Appel1977a - Every Planar Map Is Four Colorable. Part II_ Reducibility.pdf:PDF},
  fjournal     = {Illinois Journal of Mathematics},
  groups       = {Popularization, meven:4, History},
  priority     = {prio3},
  publisher    = {Duke University Press},
}

@Article{Appel1977,
  author       = {Appel, K. and Haken, W.},
  date         = {1977-09},
  journaltitle = {Illinois Journal of Mathematics},
  title        = {Every planar map is four colorable. Part I: Discharging},
  doi          = {10.1215/ijm/1256049011},
  number       = {3},
  pages        = {429--490},
  volume       = {21},
  file         = {Appel1977.pdf:Appel1977 - Every Planar Map Is Four Colorable. Part I_ Discharging.pdf:PDF},
  fjournal     = {Illinois Journal of Mathematics},
  groups       = {Popularization, meven:4, History},
  priority     = {prio3},
  publisher    = {Duke University Press},
}

@Article{Appel1977b,
  author       = {Appel, K. and Haken, W.},
  date         = {1977-09},
  journaltitle = {Illinois Journal of Mathematics},
  title        = {Microfiche supplement to “Every planar map is four colorable. Part I and Part II”},
  doi          = {10.1215/ijm/1256049023},
  number       = {3},
  volume       = {21},
  file         = {Appel1977b.pdf:Appel1977b - Microfiche Supplement to “Every Planar Map Is Four Colorable. Part I and Part II”.pdf:PDF},
  fjournal     = {Illinois Journal of Mathematics},
  groups       = {Popularization, meven:4, History},
  priority     = {prio3},
  publisher    = {Duke University Press},
  readstatus   = {skimmed},
}

@Article{Sozeau2020,
  author       = {Sozeau, Matthieu and Boulier, Simon and Forster, Yannick and Tabareau, Nicolas and Winterhalter, Th{\'e}o},
  date         = {2020-01},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {{Coq Coq Correct! Verification of Type Checking and Erasure for Coq, in Coq}},
  doi          = {10.1145/3371076},
  pages        = {1-28},
  file         = {Sozeau2020.pdf:Sozeau2020 - Coq Coq Correct! Verification of Type Checking and Erasure for Coq, in Coq.pdf:PDF},
  groups       = {meven:4, CIC, MetaCoq, Formalization},
  keywords     = {Proof assistants ; Theory of computation ; Type theory ; Certification ; Type checker},
  priority     = {prio3},
  publisher    = {{ACM}},
}

@Article{Sozeau2020a,
  author       = {Sozeau, Matthieu and Anand, Abhishek and Boulier, Simon and Cohen, Cyril and Forster, Yannick and Kunze, Fabian and Malecha, Gregory and Tabareau, Nicolas and Winterhalter, Th{\'e}o},
  date         = {2020-02},
  journaltitle = {{Journal of Automated Reasoning}},
  title        = {{The MetaCoq Project}},
  doi          = {10.1007/s10817-019-09540-0},
  url          = {https://hal.inria.fr/hal-02167423},
  file         = {:Sozeau2020a - The MetaCoq Project.pdf:PDF;The_MetaCoq_Project.pdf:https\://hal.inria.fr/hal-02167423/file/The_MetaCoq_Project.pdf:PDF},
  groups       = {MetaCoq, Formalization},
  hal_id       = {hal-02167423},
  hal_version  = {v1},
  priority     = {prio3},
  publisher    = {{Springer Verlag}},
}

@InProceedings{Abel2008,
  author    = {Abel, Andreas and Coquand, Thierry and Dybjer, Peter},
  booktitle = {Mathematics of Program Construction},
  date      = {2008},
  title     = {Verifying a Semantic $\beta$$\eta$-Conversion Test for Martin-L{\"o}f Type Theory},
  editor    = {Audebaud, Philippe and Paulin-Mohring, Christine},
  isbn      = {978-3-540-70594-9},
  location  = {Berlin, Heidelberg},
  pages     = {29--56},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Type-checking algorithms for dependent type theories often rely on the interpretation of terms in some semantic domain of values when checking equalities. Here we analyze a version of Coquand's algorithm for checking the $\beta$$\eta$-equality of such semantic values in a theory with a predicative universe hierarchy and large elimination rules. Although this algorithm does not rely on normalization by evaluation explicitly, we show that similar ideas can be employed for its verification. In particular, our proof uses the new notions of contextual reification and strong semantic equality.},
  file      = {Abel2008.pdf:Abel2008 - Verifying a Semantic $$$$ Conversion Test for Martin Lof Type Theory.pdf:PDF;:Abel2008 Extended - Verifying a Semantic $$$$ Conversion Test for Martin-Lof Type Theory.pdf:PDF},
  groups    = {meven:2, Proof Assistants, Conversion},
  priority  = {prio2},
}

@Unpublished{Herbelin2005,
  author   = {Hugo Herbelin},
  date     = {2005},
  title    = {Type inference with algebraic universes in the Calculus of Inductive Constructions},
  note     = {Unpublished Manuscript on algebraic universes},
  url      = {https://www.pauillac.inria.fr/~herbelin/articles/univalgcci.pdf},
  file     = {Herbelin2005.pdf:Herbelin2005 - Type Inference with Algebraic Universes in the Calculus of Inductive Constructions.pdf:PDF},
  groups   = {meven:3, Proof Assistants, Universes},
  priority = {prio2},
}

@InProceedings{Sozeau2014,
  author    = {Sozeau, Matthieu and Tabareau, Nicolas},
  booktitle = {Interactive Theorem Proving},
  date      = {2014},
  title     = {Universe Polymorphism in {Coq}},
  editor    = {Klein, Gerwin and Gamboa, Ruben},
  isbn      = {978-3-319-08970-6},
  location  = {Cham},
  pages     = {499--514},
  publisher = {Springer International Publishing},
  abstract  = {Universes are used in Type Theory to ensure consistency by checking that definitions are well-stratified according to a certain hierarchy. In the case of the Coq proof assistant, based on the predicative Calculus of Inductive Constructions (pCIC), this hierachy is built from an impredicative sort Prop and an infinite number of predicative Typeiuniverses. A cumulativity relation represents the inclusion order of universes in the core theory. Originally, universes were thought to be floating levels, and definitions to implicitely constrain these levels in a consistent manner. This works well for most theories, however the globality of levels and constraints precludes generic constructions on universes that could work at different levels. Universe polymorphism extends this setup by adding local bindings of universes and constraints, supporting generic definitions over universes, reusable at different levels. This provides the same kind of code reuse facilities as ML-style parametric polymorphism. However, the structure and hierarchy of universes is more complex than bare polymorphic type variables. In this paper, we introduce a conservative extension of pCIC supporting universe polymorphism and treating its whole hierarchy. This new design supports typical ambiguity and implicit polymorphic generalization at the same time, keeping it mostly transparent to the user. Benchmarking the implementation as an extension of the Coq proof assistant on real-world examples gives encouraging results.},
  file      = {Sozeau2014.pdf:Sozeau2014 - Universe Polymorphism in Coq.pdf:PDF},
  groups    = {meven:3, Proof Assistants, Universes},
  priority  = {prio3},
}

@Book{Rosenblatt1985,
  author    = {Rosenblatt, Murray and Bishop, Errett},
  date      = {1985},
  title     = {Errett Bishop: Reflections on him and his research},
  editor    = {Contemporary mathematics},
  publisher = {Providence, R.I: American Mathematical Society},
  file      = {Rosenblatt1985.djvu:Rosenblatt1985 - Errett Bishop_ Reflections on Him and His Research.djvu:Djvu},
  groups    = {Constructivism, meven:5},
  priority  = {prio3},
}

@Book{UniFoundationsProgram2013,
  author      = {{The Univalent Foundations Program}},
  date        = {2013},
  title       = {Homotopy Type Theory: Univalent Foundations of Mathematics},
  location    = {Institute for Advanced Study},
  publisher   = {\url{https://homotopytypetheory.org/book}},
  file        = {:HoTT book/UniFoundationsProgram2013 - Homotopy Type Theory_ Univalent Foundations of Mathematics.pdf:PDF},
  groups      = {HoTT, meven:5},
  priority    = {prio3},
  shortauthor = {{Univalent Foundation Program}},
}

@Book{Lang2002,
  author     = {Lang, Serge},
  date       = {2002},
  title      = {Algebra},
  doi        = {10.1007/978-1-4613-0041-0},
  isbn       = {9781461265511},
  publisher  = {Springer New York},
  series     = {Graduate Texts in Mathematics},
  volume     = {211},
  collection = {Graduate Texts in Mathematics},
  file       = {Lang2002.pdf:Lang2002 - Algebra.pdf:PDF},
  groups     = {meven:5, Mathematics Textbooks},
  place      = {New York, NY},
  priority   = {prio3},
}

@Unpublished{Barendregt1984,
  author   = {H. E. Barendregt},
  date     = {1984},
  title    = {Introduction to Lambda Calculus},
  note     = {Course Notes},
  file     = {Barendregt1984.pdf:Barendregt1984 - Introduction to Lambda Calculus.pdf:PDF},
  groups   = {Lambda Calculus, meven:5, Computer Science Textbooks},
  priority = {prio3},
}

@Book{Levy2003,
  author    = {Levy, Paul B.},
  date      = {2003},
  title     = {Call-by-push-value: A Functional/imperative Synthesis},
  publisher = {Springer},
  file      = {Levy2003.pdf:Levy2003 - Call by Push Value_ a Functional_imperative Synthesis.pdf:PDF},
  groups    = {Effects, meven:4, Semantics of PL},
  priority  = {prio3},
}

@Book{Perrin1996,
  author     = {Perrin, Daniel},
  date       = {1996},
  title      = {Cours d’algèbre},
  isbn       = {9782729855529},
  publisher  = {Ellipses},
  series     = {CAPES-agrég mathématiques},
  collection = {CAPES-agrég mathématiques},
  file       = {Perrin1996.djvu:Perrin1996 - Cours D’algèbre.djvu:Djvu},
  groups     = {meven:5, Mathematics Textbooks},
  place      = {Paris},
  priority   = {prio3},
}

@Book{Carton2014,
  author    = {Carton, Olivier},
  date      = {2014},
  title     = {Langages formels: calculabilité et complexité : cours et exercices corrigés : licence 3 \& master, mathématiques \& informatique, agrégation mathématiques},
  isbn      = {9782311014006},
  publisher = {Vuibert},
  file      = {Carton2014.djvu:Carton2014 - Langages Formels_ Calculabilité Et Complexité _ Cours Et Exercices Corrigés _ Licence 3 & Master, Mathématiques & Informatique, Agrégation Mathématiques.djvu:Djvu},
  groups    = {meven:5, Logic, Computer Science Textbooks},
  place     = {Paris},
  priority  = {prio3},
}

@Book{Riehl2016,
  author     = {Riehl, Emily},
  date       = {2016},
  title      = {Category theory in context},
  isbn       = {9780486809038},
  publisher  = {Dover Publications},
  series     = {Aurora: Dover modern math originals},
  collection = {Aurora: Dover modern math originals},
  file       = {Riehl2016.pdf:Riehl2016 - Category Theory in Context.pdf:PDF},
  groups     = {Categories, meven:5, Category Theory, Mathematics Textbooks},
  place      = {Mineola, New York},
  priority   = {prio3},
}

@Book{Bertot2010,
  author       = {Bertot, Yves and Castéran, Pierre},
  date         = {2010},
  title        = {Interactive theorem proving and program development: Coq’Art: the calculus of inductive constructions},
  isbn         = {9783642058806},
  publisher    = {Springer},
  series       = {Texts in theoretical computer science},
  abstractnote = {Coq is an interactive proof assistant for the development of mathematical theories and formally certified software. It is based on a theory called the calculus of inductive constructions, a variant of type theory. This book provides a pragmatic introduction to the development of proofs and certified programs using Coq. With its large collection of examples and exercises it is an invaluable tool for researchers, students, and engineers interested in formal methods and the development of zero-fault software},
  collection   = {Texts in theoretical computer science},
  file         = {Bertot2010.pdf:Bertot2010 - Interactive Theorem Proving and Program Development_ Coq’Art_ the Calculus of Inductive Constructions.pdf:PDF},
  groups       = {meven:5, Proof Assistants, Computer Science Textbooks, Formalization},
  place        = {Berlin},
  priority     = {prio3},
}

@Book{Amadio1998,
  author     = {Amadio, Roberto M. and Curien, P.-L.},
  date       = {1998},
  title      = {Domains and lambda-calculi},
  isbn       = {9780521622776},
  publisher  = {Cambridge University Press},
  series     = {Cambridge tracts in theoretical computer science},
  collection = {Cambridge tracts in theoretical computer science},
  file       = {Amadio1998.pdf:Amadio1998 - Domains and Lambda Calculi.pdf:PDF},
  groups     = {Lambda Calculus, meven:5, Models of TT},
  place      = {Cambridge, U.K. ; New York},
  priority   = {prio3},
}

@Book{Eiden2009,
  author    = {Eiden, Jean-Denis},
  date      = {2009},
  title     = {Géométrie analytique classique},
  isbn      = {9782916352084},
  publisher = {Calvage \& Mounet},
  file      = {Eiden2009.djvu:Eiden2009 - Géométrie Analytique Classique.djvu:Djvu},
  groups    = {meven:5, Mathematics Textbooks},
  place     = {Paris},
  priority  = {prio3},
}

@Manual{Sozeau2021,
  author   = {Sozeau, M.},
  date     = {2021-06},
  title    = {Equations 1.3beta2 Reference Manual},
  file     = {:Sozeau2021 - Equations 1.3beta2 Reference Manual.pdf:PDF},
  groups   = {meven:4, Proof Assistants, Manuals},
  priority = {prio3},
}

@Book{Appel1989,
  author     = {Appel, Kenneth I. and Haken, Wolfgang},
  date       = {1989},
  title      = {Every planar map is four colorable},
  isbn       = {9780821851036},
  publisher  = {American Mathematical Society},
  series     = {Contemporary mathematics},
  collection = {Contemporary mathematics},
  file       = {Appel1989.djvu:Appel1989 - Every Planar Map Is Four Colorable.djvu:Djvu},
  groups     = {Popularization, meven:5, History},
  place      = {Providence, R.I},
  priority   = {prio3},
}

@Book{Francinou1995,
  author     = {Francinou, Serge and Gianella, Hervé},
  date       = {1995},
  title      = {Exercices de mathématiques pour l’agrégation: algèbre. 1: ...},
  isbn       = {9782225843662},
  publisher  = {Masson},
  series     = {Agrégation de mathématiques},
  collection = {Agrégation de mathématiques},
  file       = {Francinou1995.djvu:Francinou1995 - Exercices De Mathématiques Pour L’agrégation_ Algèbre. 1_ ....djvu:Djvu},
  groups     = {meven:5, Mathematics Textbooks},
  place      = {Paris},
  priority   = {prio3},
}

@Book{Baader1998,
  author    = {Baader, Franz and Nipkow, Tobias},
  date      = {1998},
  title     = {Term rewriting and all that},
  isbn      = {9780521455206},
  publisher = {Cambridge University Press},
  file      = {Baader1998.djvu:Baader1998 - Term Rewriting and All That.djvu:Djvu},
  groups    = {meven:5, Computer Science Textbooks},
  place     = {Cambridge ; New York},
  priority  = {prio3},
}

@Book{Girard1989,
  author     = {Girard, Jean-Yves},
  date       = {1989},
  title      = {Proofs and types},
  isbn       = {9780521371810},
  publisher  = {Cambridge University Press},
  series     = {Cambridge tracts in theoretical computer science},
  collection = {Cambridge tracts in theoretical computer science},
  file       = {Girard1989.pdf:Girard1989 - Proofs and Types.pdf:PDF},
  groups     = {meven:5, Logic, Computer Science Textbooks, History},
  place      = {Cambridge [England] ; New York},
  priority   = {prio3},
}

@Unpublished{Danos1992,
  author   = {Vincent Danos and Roberto {Di Cosmo}},
  date     = {1992-06},
  title    = {Introduction to Linear Logic},
  note     = {Course Notes, very preliminary version of \cite{LLPrimer97}},
  url      = {http://www.dicosmo.org/CorsoPisa.dvi},
  file     = {Danos1992.pdf:Danos1992 - Introduction to Linear Logic.pdf:PDF},
  groups   = {meven:5, Linear Logic, Computer Science Textbooks},
  priority = {prio3},
}

@Book{Jacobs2017,
  author     = {Jacobs, Bart},
  date       = {2017},
  title      = {Introduction to coalgebra: towards mathematics of states and observation},
  isbn       = {9781107177895},
  publisher  = {Cambridge University Press},
  series     = {Cambridge tracts in theoretical computer science},
  collection = {Cambridge tracts in theoretical computer science},
  file       = {Jacobs2017.pdf:Jacobs2017 - Introduction to Coalgebra_ Towards Mathematics of States and Observation.pdf:PDF},
  groups     = {meven:5, Category Theory, Computer Science Textbooks},
  place      = {Cambridge},
  priority   = {prio3},
}

@Book{Grifone2016,
  author    = {Grifone, Jean},
  date      = {2016},
  title     = {Algèbre linéaire},
  isbn      = {9782364931831},
  publisher = {Éditions Cépaduès},
  file      = {Grifone2016.djvu:Grifone2016 - Algèbre Linéaire.djvu:Djvu},
  groups    = {meven:5, Mathematics Textbooks},
  priority  = {prio3},
}

@Book{David2003,
  author    = {David, René and Nour, Karim and Raffali, Christophe},
  date      = {2003},
  title     = {Introduction à la Logique : Théorie de la démonstration},
  publisher = {Dunot},
  file      = {David2003.djvu:David2003 - Introduction À La Logique _ Théorie De La Démonstration.djvu:Djvu},
  groups    = {meven:5, Logic, Computer Science Textbooks},
  keywords  = {DNR},
  priority  = {prio3},
}

@Unpublished{Winskel2005,
  author   = {Winskel, Glynn and Pitts, Andrew},
  date     = {2005},
  title    = {Lecture Notes on Denotational Semantics},
  note     = {Lecture Notes},
  file     = {Winskel2005.pdf:Winskel2005 - Lecture Notes on Denotational Semantics.pdf:PDF},
  groups   = {meven:5, Computer Science Textbooks},
  priority = {prio3},
}

@Book{Soerensen2006,
  author    = {Morten Heine Sørensen and Pawel Urzyczyn},
  date      = {2006},
  title     = {Lectures on the Curry-Howard isomorphism},
  publisher = {Elsevier Science},
  series    = {Studies in Logic and the Foundations of Mathematics},
  volume    = {149},
  file      = {Srensen2006.pdf:Soerensen2006 - Lectures on the Curry Howard Isomorphism.pdf:PDF},
  groups    = {Lambda Calculus, meven:5, Pure Type Systems, Computer Science Textbooks},
  priority  = {prio3},
}

@Book{Crochemore2007,
  author    = {Crochemore, Maxime and Hancart, Christophe and Lecroq, Thierry},
  date      = {2007},
  title     = {Algorithms on strings},
  publisher = {Cambridge University Press},
  file      = {:Crochemore2007 - Algorithms on Strings.pdf:PDF},
  groups    = {Algorithmics, Computer Science Textbooks},
  priority  = {prio3},
}

@Book{Gathen2013,
  author    = {Gathen, Joachim von zur and Gerhard, Jürgen},
  date      = {2013},
  title     = {Modern Computer Algebra},
  edition   = {Third edition},
  isbn      = {9781107039032},
  publisher = {Cambridge University Press},
  file      = {:Gathen2013 - Modern Computer Algebra.pdf:PDF},
  groups    = {Algorithmics, Mathematics Textbooks},
  place     = {Cambridge},
  priority  = {prio3},
}

@Unpublished{Voevodsky2012,
  author   = {Vladimir Voevodsky},
  date     = {2012},
  title    = {A universe polymorphic type system},
  file     = {:Voevodsky2012 - A Universe Polymorphic Type System.pdf:PDF},
  groups   = {Universes},
  priority = {prio3},
}

@PhdThesis{Gilbert2020,
  author   = {Gaëtan Gilbert},
  date     = {2020},
  title    = {A type theory with definitional proof-irrelevance},
  file     = {:Gilbert2020 - A Type Theory with Definitional Proof Irrelevance.pdf:PDF},
  groups   = {Irrelevance},
  priority = {prio3},
}

@Book{Odifreddi1999,
  author    = {Piergiorgio Odifreddi},
  date      = {1999},
  title     = {Classical recursion theory : the theory of functions and sets of natural numbers},
  edition   = {2},
  publisher = {North Holland},
  file      = {:Odifreddi1999 - Classical Recursion Theory _ the Theory of Functions and Sets of Natural Numbers.pdf:PDF},
  groups    = {Computer Science Textbooks},
  priority  = {prio3},
}

@InBook{Veldman2009,
  author    = {Veldman, Wim},
  booktitle = {Logicism, Intuitionism, and Formalism. Synthese Library (Studies In Epistemology. Logic, Methodology, and Philosophy of Science)},
  date      = {2009-01},
  title     = {Brouwer’s Approximate Fixed-Point Theorem is Equivalent to Brouwer’s Fan Theorem},
  doi       = {10.1007/978-1-4020-8926-8_14},
  pages     = {277-299},
  file      = {:Veldman2009 - Brouwer’s Approximate Fixed Point Theorem Is Equivalent to Brouwer’s Fan Theorem.pdf:PDF},
  groups    = {Constructivism},
  priority  = {prio3},
}

@InProceedings{Griffin1989,
  author    = {Griffin, Timothy G.},
  booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  date      = {1989},
  title     = {A Formulae-as-Type Notion of Control},
  doi       = {10.1145/96709.96714},
  isbn      = {0897913434},
  location  = {San Francisco, California, USA},
  pages     = {47–58},
  publisher = {Association for Computing Machinery},
  series    = {POPL ’90},
  address   = {New York, NY, USA},
  file      = {:Griffin1989 - A Formulae As Type Notion of Control.pdf:PDF},
  groups    = {Effects},
  numpages  = {12},
  priority  = {prio3},
}

@Book{Caldero2017,
  author    = {Philippe Caldero and Jérôme Germoni},
  date      = {2017},
  title     = {Nouvelle Histoires Hédonistes de Groupes et de Géométries. Tome premier.},
  publisher = {Calvage \& Mounet},
  file      = {:Caldero2017 - Nouvelle Histoires Hédonistes De Groupes Et De Géométries. Tome Premier..djvu:Djvu},
  groups    = {Mathematics Textbooks},
  priority  = {prio3},
}

@Book{Aigner2018,
  author    = {Martin Aigner and Günter Matthias Ziegler},
  date      = {2018},
  title     = {Proofs from The Book},
  edition   = {6},
  publisher = {Springer},
  file      = {:Aigner2018 - Proofs from the Book.pdf:PDF},
  groups    = {Mathematics Textbooks, Popularization},
  priority  = {prio3},
}

@Book{Nielson1992,
  author    = {Nielson, Hanne Riis and Nielson, Flemming},
  date      = {1992},
  title     = {Semantics with Applications: A Formal Introduction},
  isbn      = {0471929808},
  publisher = {John Wiley & Sons, Inc.},
  file      = {:Nielson1992 - Semantics with Applications_ a Formal Introduction.pdf:PDF},
  groups    = {Semantics of PL, Computer Science Textbooks},
  priority  = {prio3},
}

@Unpublished{Streicher2004,
  author   = {Thomas Streicher},
  date     = {2004},
  title    = {Introduction to Category Theory and Categorical Logic},
  pubstate = {Lecture Notes},
  file     = {:Streicher2004 - Introduction to Category Theory and Categorical Logic.pdf:PDF},
  groups   = {Category Theory, Computer Science Textbooks},
  priority = {prio3},
}

@InBook{Escardo2004,
  author    = {Martín Escardó},
  booktitle = {Electronic Notes in Theoretical Computer Science},
  date      = {2004},
  title     = {Synthetic topology of data types and classical spaces},
  pages     = {21-156},
  publisher = {Elsevier},
  volume    = {87},
  file      = {:Escardo2004 - Synthetic Topology of Data Types and Classical Spaces.pdf:PDF},
  groups    = {Semantics of PL, Topology},
  priority  = {prio3},
}

@Book{Awodey2010,
  author     = {Awodey, Steve},
  date       = {2010},
  title      = {Category theory},
  edition    = {2},
  isbn       = {9780199587360},
  publisher  = {Oxford University Press},
  series     = {Oxford logic guides},
  collection = {Oxford logic guides},
  file       = {:Awodey2010 - Category Theory.pdf:PDF},
  groups     = {Category Theory, Computer Science Textbooks},
  place      = {Oxford ; New York},
  priority   = {prio3},
}

@Book{Cormen2009,
  author    = {Cormen, Thomas H. and Leiserson, Charles E. and Rivest, Ronald L. and Stein, Clifford},
  date      = {2009},
  title     = {Introduction to algorithms},
  edition   = {3},
  isbn      = {9780262033848},
  publisher = {MIT Press},
  file      = {:Cormen2009 - Introduction to Algorithms.pdf:PDF},
  groups    = {Algorithmics, Computer Science Textbooks},
  priority  = {prio3},
}

@Book{MacLane1994,
  author     = {Mac Lane, Saunders and Moerdijk, Ieke},
  date       = {1994},
  title      = {Sheaves in Geometry and Logic: A First Introduction to Topos Theory},
  doi        = {10.1007/978-1-4612-0927-0},
  isbn       = {9780387977102},
  publisher  = {Springer New York},
  series     = {Universitext},
  collection = {Universitext},
  file       = {:MacLane1994 - Sheaves in Geometry and Logic_ a First Introduction to Topos Theory.djvu:Djvu},
  groups     = {Category Theory, Mathematics Textbooks},
  priority   = {prio3},
}

@InBook{Hofmann1997,
  author    = {Hofmann, Martin},
  booktitle = {Extensional Constructs in Intensional Type Theory},
  date      = {1997},
  title     = {Syntax and semantics of dependent types},
  doi       = {10.1007/978-1-4471-0963-1_2},
  isbn      = {978-1-4471-0963-1},
  location  = {London},
  pages     = {13--54},
  publisher = {Springer London},
  abstract  = {In this chapter we fix a particular syntax for a dependently typed calculus and define an abstract notion of model as well as a general interpretation function mapping syntactical objects to entities in a model. This interpretation function is shown to be sound with respect to the syntax.},
  file      = {:Hofmann1997 - Syntax and Semantics of Dependent Types.pdf:PDF},
  groups    = {Models of TT},
  priority  = {prio3},
}

@Article{Coquand1996,
  author       = {Thierry Coquand},
  date         = {1996},
  journaltitle = {Science of Computer Programming},
  title        = {An algorithm for type-checking dependent types},
  doi          = {10.1016/0167-6423(95)00021-6},
  issn         = {0167-6423},
  number       = {1},
  url          = {http://www.sciencedirect.com/science/article/pii/0167642395000216},
  volume       = {26},
  abstract     = {We present a simple type-checker for a language with dependent types and let expressions, with a simple proof of correctness.},
  file         = {:Coquand1996 - An Algorithm for Type Checking Dependent Types.pdf:PDF},
  groups       = {Bidirectional Typing, Proof Assistants},
  priority     = {prio2},
}

@Conference{McBride2019,
  author    = {McBride, Conor},
  booktitle = {25th International Conference on Types for Proofs and Programs},
  date      = {2019-06-14},
  title     = {Check the Box!},
  groups    = {Bidirectional Typing},
  priority  = {prio3},
}

@Unpublished{McBride2018,
  author   = {McBride, Conor},
  date     = {2018-08-06},
  title    = {Basics of Bidirectionalism},
  note     = {Blog post},
  url      = {https://pigworker.wordpress.com/2018/08/06/basics-of-bidirectionalism/},
  urldate  = {2022-05-30},
  comment  = {Blog post},
  groups   = {Bidirectional Typing},
  priority = {prio3},
}

@Article{Awodey1996,
  author       = {S. Awodey},
  date         = {1996},
  journaltitle = {Philosophia Mathematica},
  title        = {Structure in Mathematics and Logic: A Categorical Perspective},
  doi          = {10.1093/philmat/4.3.209},
  number       = {3},
  pages        = {209--237},
  volume       = {4},
  file         = {:Awodey1996 - Structure in Mathematics and Logic_ a Categorical Perspective.pdf:PDF},
  groups       = {Category Theory, Logic, Topoi},
  priority     = {prio3},
  publisher    = {Oxford University Press},
}

@Article{Pierce2000,
  author       = {Pierce, Benjamin C. and Turner, David N.},
  date         = {2000-01},
  journaltitle = {ACM Transactions on Programming Languages and Systems},
  title        = {Local Type Inference},
  doi          = {10.1145/345099.345100},
  issn         = {0164-0925},
  number       = {1},
  pages        = {1–44},
  volume       = {22},
  file         = {:Pierce2000 - Local Type Inference.pdf:PDF},
  groups       = {Bidirectional Typing},
  issue_date   = {Jan. 2000},
  keywords     = {subtyping, type inference, polymorphism},
  location     = {New York, NY, USA},
  numpages     = {44},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@InBook{DeBruijn1991,
  author    = {De Bruijn, N. G.},
  booktitle = {Logical Frameworks},
  date      = {1991},
  title     = {A plea for weaker frameworks},
  doi       = {10.1017/CBO9780511569807.004},
  editor    = {Huet, Gerard and Plotkin, Gordon},
  pages     = {40–68},
  publisher = {Cambridge University Press},
  file      = {:DeBruijn1991 - A Plea for Weaker Frameworks.pdf:PDF},
  groups    = {Proof Assistants, History},
  place     = {Cambridge},
  priority  = {prio3},
}

@Article{Abel2012,
  author       = {Abel, Andreas and Scherer, Gabriel},
  date         = {2012-03},
  journaltitle = {{Logical Methods in Computer Science}},
  title        = {{On Irrelevance and Algorithmic Equality in Predicative Type Theory}},
  doi          = {10.2168/LMCS-8(1:29)2012},
  url          = {https://lmcs.episciences.org/1045},
  volume       = {Volume 8, Issue 1},
  file         = {:Abel2012 - On Irrelevance and Algorithmic Equality in Predicative Type Theory.pdf:PDF},
  groups       = {Irrelevance},
  keywords     = {Computer Science - Logic in Computer Science ; Computer Science - Programming Languages ; F.4.1},
  priority     = {prio3},
}

@InProceedings{Geuvers2001,
  author    = {Geuvers, Herman},
  booktitle = {Typed Lambda Calculi and Applications},
  date      = {2001},
  title     = {Induction Is Not Derivable in Second Order Dependent Type Theory},
  editor    = {Abramsky, Samson},
  isbn      = {978-3-540-45413-7},
  location  = {Berlin, Heidelberg},
  pages     = {166--181},
  publisher = {Springer Berlin Heidelberg},
  file      = {:Geuvers2001 - Induction Is Not Derivable in Second Order Dependent Type Theory.ps:PostScript},
  groups    = {Inductive Types, Models of TT, Pure Type Systems},
  priority  = {prio3},
}

@PhdThesis{Sozeau2008,
  author      = {Matthieu Sozeau},
  date        = {2008},
  institution = {Université Paris 11},
  title       = {Un environnement pour la programmation avec types dépendants},
  file        = {:Sozeau2008 - Un Environnement Pour La Programmation Avec Types Dépendants.pdf:PDF},
  groups      = {Bidirectional Typing, Proof Assistants},
  priority    = {prio3},
}

@Article{Dunfield2021,
  author       = {Dunfield, Jana and Krishnaswami, Neel},
  date         = {2021-05},
  journaltitle = {ACM Computing Surveys},
  title        = {Bidirectional Typing},
  doi          = {10.1145/3450952},
  issn         = {0360-0300},
  number       = {5},
  volume       = {54},
  abstract     = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner’s local type inference to the present day, and provide guidance for future investigations.},
  articleno    = {98},
  file         = {:Dunfield2021 - Bidirectional Typing.pdf:PDF},
  issue_date   = {June 2022},
  keywords     = {Type checking, type inference},
  location     = {New York, NY, USA},
  numpages     = {38},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@InBook{McBride2016,
  author    = {McBride, Conor},
  booktitle = {A List of Successes That Can Change the World: Essays Dedicated to Philip Wadler on the Occasion of His 60th Birthday},
  date      = {2016},
  title     = {I Got Plenty o' Nuttin'},
  doi       = {10.1007/978-3-319-30936-1_12},
  editor    = {Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don},
  isbn      = {978-3-319-30936-1},
  pages     = {207--233},
  publisher = {Springer International Publishing},
  file      = {:McBride2016 - I Got Plenty O' Nuttin'.pdf:PDF},
  groups    = {Bidirectional Typing, Linear Logic},
  priority  = {prio3},
}

@InProceedings{Polikarpova2016,
  author    = {Polikarpova, Nadia and Kuraj, Ivan and Solar-Lezama, Armando},
  date      = {2016},
  title     = {Program Synthesis from Polymorphic Refinement Types},
  doi       = {10.1145/2908080.2908093},
  isbn      = {9781450342612},
  location  = {Santa Barbara, CA, USA},
  pages     = {522–538},
  publisher = {Association for Computing Machinery},
  series    = {PLDI '16},
  file      = {:Polikarpova2016 - Program Synthesis from Polymorphic Refinement Types.pdf:PDF},
  groups    = {Bidirectional Typing},
  keywords  = {Predicate Abstraction, Program Synthesis, Functional Programming, Refinement Types},
  numpages  = {17},
  priority  = {prio3},
}

@Article{Loeh2010,
  author       = {Andres L{\"o}h and Conor Mcbride and Wouter Swierstra},
  date         = {2010},
  journaltitle = {Fundamenta Informaticae},
  title        = {A tutorial implementation of a dependently typed lambda calculus},
  number       = {2},
  pages        = {177--207},
  url          = {https://strathprints.strath.ac.uk/36006/},
  volume       = {102},
  file         = {:Loeh2010 - A Tutorial Implementation of a Dependently Typed Lambda Calculus.pdf:PDF},
  groups       = {Bidirectional Typing, Computer Science Textbooks, Proof Assistants},
  keywords     = {core calculus, lambda calculus, Haskell, Electronic computers. Computer science, Computational Theory and Mathematics, Algebra and Number Theory, Theoretical Computer Science, Information Systems},
  priority     = {prio3},
}

@Eprint{Bauer2020,
  author      = {Andrej Bauer and Philipp G. Haselwarter and Peter LeFanu Lumsdaine},
  date        = {2020},
  eprint      = {2009.05539},
  eprintclass = {math.LO},
  eprinttype  = {arXiv},
  file        = {:Bauer2020 - A General Definition of Dependent Type Theories.pdf:PDF},
  groups      = {Dependent types},
  priority    = {prio3},
  title       = {A general definition of dependent type theories},
}

@Unpublished{Asai2016,
  author   = {Asai, Kenichi and Kadowaki, Kyoko},
  date     = {2016},
  title    = {A Type Theoretic Specification of Type Inference},
  file     = {:Asai2016 - A Type Theoretic Specification of Type Inference.pdf:PDF},
  groups   = {Bidirectional Typing},
  priority = {prio3},
}

@Article{Harper1991,
  author       = {Robert Harper and Robert Pollack},
  date         = {1991},
  journaltitle = {Theoretical Computer Science},
  title        = {Type checking with universes},
  doi          = {10.1016/0304-3975(90)90108-T},
  issn         = {0304-3975},
  number       = {1},
  url          = {http://www.sciencedirect.com/science/article/pii/030439759090108T},
  volume       = {89},
  abstract     = {Various formulations of constructive type theories have been proposed to serve as the basis for machine-assisted proof and as a theoretical basis for studying programming languages. Many of these calculi include a cumulative hierarchy of “universes”, each a type of types closed under a collection of type-forming operations. Universes are of interest for a variety of reasons, some philosophical (predicative vs. impredicative type theories), some theoretical (limitations on the closure properties of type theories) and some practical (to achieve some of the advantages of a type of all types without sacrificing consistency.) The Generalized Calculus of Constructions (CCω) is a formal theory of types that includes such a hierarchy of universes. Although essential to the formalization of constructive mathematics, universes are tedious to use in practice, for one is required to make specific choices of universe levels and to ensure that all choices are consistent. In this paper we study several problems associated with type checking in the presence of universes in the context of CCω. First, we consider the basic type checking and well-typedness problems for this calculus. Second, we consider a formulation of Russell and Whitehead's “typical ambiguity” convention whereby universe levels may be elided, provided that some consistent assignment of levels leads to a correct derivation. Third, we consider the introduction of definitions to both the basic calculus and the calculus with typical ambiguity. This extension leads to a notion of “universe polymorphism” analogous to the type polymorphism of ML. Although our study is conducted for CCω, we expect that our methods will apply to other variants of the Calculus of Constructions and to type theories such as Constable's V3.},
  comment      = {Typical ambiguity},
  file         = {:Harper1991 - Type Checking with Universes.pdf:PDF},
  groups       = {Proof Assistants, Universes, Pure Type Systems},
  keywords     = {Typical Ambiguity},
  priority     = {prio2},
}

@Book{Mines1987,
  author    = {Ray Mines and Fred Richman and Wim Ruitenburg},
  date      = {1987},
  title     = {A Course in Constructive Algebra (Universitext)},
  edition   = {1988},
  publisher = {Springer},
  series    = {Universitext},
  file      = {:Mines1987 - A Course in Constructive Algebra (Universitext).djvu:Djvu},
  groups    = {Constructivism, Mathematics Textbooks},
  priority  = {prio3},
}

@Book{Mines2020,
  author     = {Ray Mines and Fred Richman and Wim Ruitenberg},
  date       = {2020-02},
  title      = {Un cours d’algèbre constructive},
  publisher  = {Presses Universitaires de Franche-Comté},
  translator = {Henri Lombardi},
  file       = {:Mines2020 - Un Cours D’algèbre Constructive.pdf:PDF},
  groups     = {Constructivism, Mathematics Textbooks},
  priority   = {prio3},
}

@Article{Eilenberg1945,
  author       = {Eilenberg, Samuel and {Mac Lane}, Saunders},
  date         = {1945},
  journaltitle = {Transactions of the American Mathematical Society},
  title        = {General theory of natural equivalences},
  pages        = {231--294},
  volume       = {58},
  file         = {:Eilenberg1945 - General Theory of Natural Equivalences.pdf:PDF},
  groups       = {Category Theory, History},
  priority     = {prio3},
  readstatus   = {skimmed},
}

@Article{Laan1996,
  author       = {Twan Laan and Rob Nederpelt},
  date         = {1996},
  journaltitle = {Studia Logica: An International Journal for Symbolic Logic},
  title        = {A Modern Elaboration of the Ramified Theory of Types},
  number       = {2/3},
  pages        = {243--278},
  url          = {http://www.jstor.org/stable/20015876},
  volume       = {57},
  abstract     = {The paper first formalizes the ramified type theory as (informally) described in the Principia Mathematica [32]. This formalization is close to the ideas of the Principia, but also meets contemporary requirements on formality and accuracy, and therefore is a new supply to the known literature on the Principia (like [25], [19], [6] and [7]). As an alternative, notions from the ramified type theory are expressed in a lambda calculus style. This situates the type system of Russell and Whitehead in a modern setting. Both formalizations are inspired by current developments in research on type theory and typed lambda calculus; see [3].},
  file         = {:Laan1996 - A Modern Elaboration of the Ramified Theory of Types.pdf:PDF},
  groups       = {Logic},
  priority     = {prio3},
  publisher    = {Springer},
}

@InProceedings{Pollack1992,
  author    = {R. Pollack},
  booktitle = {Informal Proceedings of the 1992 Workshop on Types for Proofs and Programs, B\aa stad, Sweden},
  date      = {1992-06},
  title     = {Typechecking in {P}ure {T}ype {S}ystems},
  pages     = {271-288},
  url       = {http://homepages.inf.ed.ac.uk/rpollack/export/BaastadTypechecking.ps.gz},
  file      = {:Pollack1992 - Typechecking in Pure Type Systems.ps:PostScript},
  groups    = {Bidirectional Typing, Pure Type Systems, Proof Assistants},
  priority  = {prio2},
}

@InCollection{Barendregt1992,
  author    = {Barendregt, Henk},
  booktitle = {Handbook of Logic in Computer Science},
  date      = {1992},
  title     = {Lambda Calculi with Types},
  file      = {:Barendregt1992 - Lambda Calculi with Types.pdf:PDF},
  groups    = {Pure Type Systems, Computer Science Textbooks},
  priority  = {prio3},
}

@InBook{Huet1989,
  author    = {Huet, Gérard},
  booktitle = {A Perspective in Theoretical Computer Science},
  date      = {1989},
  title     = {The Constructive Engine},
  doi       = {10.1142/9789814368452_0004},
  eprint    = {https://www.worldscientific.com/doi/pdf/10.1142/9789814368452_0004},
  pages     = {38-69},
  abstract  = {Abstract The following sections are included: Introduction Technical Preliminaries λ-calculus in the de Bruijn notation Sharing morphisms Binding morphisms with sharing Application to the Calculus of Constructions Term and types Substitution Equality Structure of the environment A digression on the meaning of inference rules Initialization Resetting the current judgement Resetting, pushing and popping the environment Searching the environment The basic machine operations Introducing a new hypothesis Introducing a new definition Global Introduction Prop intro Type intro App intro Discharging definitions Lambda Introduction Product Introduction Type conversion Higher-level commands Sections Inductive definitions The mathematical vernacular A small vernacular syllabus Expressions Commands A full exemple: Newman's lemma Conclusion References},
  file      = {:Huet1989 - The Constructive Engine.pdf:PDF},
  groups    = {Proof Assistants, Bidirectional Typing, Conversion, CIC},
  priority  = {prio3},
}

@InProceedings{Timany2018,
  author     = {Amin Timany and Matthieu Sozeau},
  booktitle  = {3rd International Conference on Formal Structures for Computation and Deduction (FSCD 2018)},
  date       = {2018},
  title      = {{Cumulative Inductive Types In {Coq}}},
  doi        = {10.4230/LIPIcs.FSCD.2018.29},
  editor     = {H{\'e}l{\`e}ne Kirchner},
  isbn       = {978-3-95977-077-4},
  location   = {Dagstuhl, Germany},
  pages      = {1--16},
  publisher  = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  series     = {Leibniz International Proceedings in Informatics (LIPIcs)},
  url        = {http://drops.dagstuhl.de/opus/volltexte/2018/9199},
  volume     = {108},
  annotation = {Keywords: Coq, Proof Assistants, Inductive Types, Universes, Cumulativity},
  file       = {:Timany2018 - Cumulative Inductive Types in Coq.pdf:PDF},
  groups     = {Proof Assistants, Universes, Inductive Types},
  issn       = {1868-8969},
  priority   = {prio2},
  urn        = {urn:nbn:de:0030-drops-91991},
}

@Article{Saibi1997,
  author       = {Saïbi, Amokrane},
  date         = {1997},
  journaltitle = {Proceedings of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages - POPL ’97. doi:10.1145/263699.263742},
  title        = {Typing Algorithm in Type Theory with Inheritance},
  doi          = {10.1145/263699.263742},
  file         = {:Saibi1997 - Typing Algorithm in Type Theory with Inheritance.pdf:PDF},
  groups       = {Bidirectional Typing, Proof Assistants},
  priority     = {prio3},
}

@PhdThesis{Norell2007,
  author      = {Ulf Norell},
  date        = {2007-09},
  institution = {Department of Computer Science and Engineering, Chalmers University of Technology},
  title       = {Towards a practical programming language based on dependent type theory},
  file        = {:Norell2007 - Towards a Practical Programming Language Based on Dependent Type Theory.pdf:PDF},
  groups      = {Bidirectional Typing, Proof Assistants},
  priority    = {prio3},
}

@InProceedings{Sozeau2007,
  author    = {Sozeau, Matthieu},
  booktitle = {Types for Proofs and Programs},
  date      = {2007},
  title     = {Subset Coercions in Coq},
  editor    = {Altenkirch, Thorsten and McBride, Conor},
  isbn      = {978-3-540-74464-1},
  location  = {Berlin, Heidelberg},
  pages     = {237--252},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We propose a new language for writing programs with dependent types on top of the Coq proof assistant. This language permits to establish a phase distinction between writing and proving algorithms in the Coq environment. Concretely, this means allowing to write algorithms as easily as in a practical functional programming language whilst giving them as rich a specification as desired and proving that the code meets the specification using the whole Coq proof apparatus. This is achieved by extending conversion to an equivalence which relates types and subsets based on them, a technique originating from the ``Predicate subtyping'' feature of PVS and following mathematical convention. The typing judgements can be translated to the (CIC) by means of an interpretation which inserts coercions at the appropriate places. These coercions can contain existential variables representing the propositional parts of the final term, corresponding to proof obligations (or PVS type-checking conditions). A prototype implementation of this process is integrated with the Coq environment.},
  groups    = {Bidirectional Typing},
  priority  = {prio3},
}

@InProceedings{Cohen2015,
  author      = {Cohen, Cyril and Coquand, Thierry and Huber, Simon and M{\"o}rtberg, Anders},
  booktitle   = {{21st International Conference on Types for Proofs and Programs}},
  date        = {2015-05},
  title       = {{Cubical Type Theory: a constructive interpretation of the univalence axiom}},
  doi         = {10.4230/LIPIcs.TYPES.2015.5},
  location    = {Tallinn, Estonia},
  number      = {69},
  pages       = {262},
  publisher   = {{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik}},
  series      = {21st International Conference on Types for Proofs and Programs},
  url         = {https://hal.inria.fr/hal-01378906},
  file        = {:https\://arxiv.org/pdf/1611.02108:;:Cohen2015 - Cubical Type Theory_ a Constructive Interpretation of the Univalence Axiom.pdf:PDF;LIPIcs-TYPES-2015-5.pdf:https\://hal.inria.fr/hal-01378906v2/file/LIPIcs-TYPES-2015-5.pdf:PDF},
  groups      = {HoTT},
  hal_id      = {hal-01378906},
  hal_version = {v2},
  keywords    = {Univalence Axiom ; Dependent Type Theory ; Cubical Sets},
  priority    = {prio3},
}

@Article{Cockx2021,
  author       = {Cockx, Jesper and Tabareau, Nicolas and Winterhalter, Th{\'e}o},
  date         = {2021},
  journaltitle = {{Proceedings of the ACM on Programming Languages}},
  title        = {{The Taming of the Rew: A Type Theory with Computational Assumptions}},
  series       = {POPL 2021},
  url          = {https://hal.archives-ouvertes.fr/hal-02901011},
  file         = {:Cockx2021 - The Taming of the Rew_ a Type Theory with Computational Assumptions.pdf:PDF;main_popl.pdf:https\://hal.archives-ouvertes.fr/hal-02901011v2/file/main_popl.pdf:PDF},
  groups       = {MLTT, MetaCoq},
  hal_id       = {hal-02901011},
  keywords     = {type theory ; confluence ; dependent types ; rewriting ; termination},
  priority     = {prio3},
  publisher    = {{ACM}},
}

@Article{Abel2017,
  author       = {Abel, Andreas and \"{O}hman, Joakim and Vezzosi, Andrea},
  date         = {2017-12},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {Decidability of Conversion for Type Theory in Type Theory},
  doi          = {10.1145/3158111},
  number       = {POPL},
  volume       = {2},
  abstract     = {Type theory should be able to handle its own meta-theory, both to justify its foundational claims and to obtain a verified implementation. At the core of a type checker for intensional type theory lies an algorithm to check equality of types, or in other words, to check whether two types are convertible. We have formalized in Agda a practical conversion checking algorithm for a dependent type theory with one universe \`{a} la Russell, natural numbers, and η-equality for Π types. We prove the algorithm correct via a Kripke logical relation parameterized by a suitable notion of equivalence of terms. We then instantiate the parameterized fundamental lemma twice: once to obtain canonicity and injectivity of type formers, and once again to prove the completeness of the algorithm. Our proof relies on inductive-recursive definitions, but not on the uniqueness of identity proofs. Thus, it is valid in variants of intensional Martin-L\"{o}f Type Theory as long as they support induction-recursion, for instance, Extensional, Observational, or Homotopy Type Theory.},
  articleno    = {23},
  file         = {:Abel2017 - Decidability of Conversion for Type Theory in Type Theory.pdf:PDF},
  groups       = {Conversion},
  issue_date   = {January 2018},
  keywords     = {Agda, Dependent types, Logical relations, Formalization},
  location     = {New York, NY, USA},
  numpages     = {29},
  priority     = {prio2},
  publisher    = {Association for Computing Machinery},
}

@Article{Abel2017a,
  author       = {Abel, Andreas and Vezzosi, Andrea and Winterhalter, Theo},
  date         = {2017-08},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {Normalization by Evaluation for Sized Dependent Types},
  doi          = {10.1145/3110277},
  number       = {ICFP},
  volume       = {1},
  abstract     = {Sized types have been developed to make termination checking more perspicuous, more powerful, and more modular by integrating termination into type checking. In dependently-typed proof assistants where proofs by induction are just recursive functional programs, the termination checker is an integral component of the trusted core, as validity of proofs depend on termination. However, a rigorous integration of full-fledged sized types into dependent type theory is lacking so far. Such an integration is non-trivial, as explicit sizes in proof terms might get in the way of equality checking, making terms appear distinct that should have the same semantics. In this article, we integrate dependent types and sized types with higher-rank size polymorphism, which is essential for generic programming and abstraction. We introduce a size quantifier ∀ which lets us ignore sizes in terms for equality checking, alongside with a second quantifier Π for abstracting over sizes that do affect the semantics of types and terms. Judgmental equality is decided by an adaptation of normalization-by-evaluation for our new type theory, which features type shape-directed reflection and reification. It follows that subtyping and type checking of normal forms are decidable as well, the latter by a bidirectional algorithm.},
  articleno    = {33},
  file         = {:Abel2017a - Normalization by Evaluation for Sized Dependent Types.pdf:PDF},
  groups       = {Bidirectional Typing, Normalization by evaluation},
  issue_date   = {September 2017},
  keywords     = {universes, proof irrelevance, dependent types, subtyping, normalization-by-evaluation, sized types, eta-equality},
  location     = {New York, NY, USA},
  numpages     = {30},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@Article{Vezzosi2019,
  author       = {Vezzosi, Andrea and M\"{o}rtberg, Anders and Abel, Andreas},
  date         = {2019-07},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {Cubical Agda: A Dependently Typed Programming Language with Univalence and Higher Inductive Types},
  doi          = {10.1145/3341691},
  number       = {ICFP},
  volume       = {3},
  abstract     = {Proof assistants based on dependent type theory provide expressive languages for both programming and proving within the same system. However, all of the major implementations lack powerful extensionality principles for reasoning about equality, such as function and propositional extensionality. These principles are typically added axiomatically which disrupts the constructive properties of these systems. Cubical type theory provides a solution by giving computational meaning to Homotopy Type Theory and Univalent Foundations, in particular to the univalence axiom and higher inductive types. This paper describes an extension of the dependently typed functional programming language Agda with cubical primitives, making it into a full-blown proof assistant with native support for univalence and a general schema of higher inductive types. These new primitives make function and propositional extensionality as well as quotient types directly definable with computational content. Additionally, thanks also to copatterns, bisimilarity is equivalent to equality for coinductive types. This extends Agda with support for a wide range of extensionality principles, without sacrificing type checking and constructivity.},
  articleno    = {87},
  file         = {:Vezzosi2019 - Cubical Agda_ a Dependently Typed Programming Language with Univalence and Higher Inductive Types.pdf:PDF},
  groups       = {MLTT, Proof Assistants},
  issue_date   = {August 2019},
  keywords     = {Dependent Pattern Matching, Higher Inductive Types, Cubical Type Theory, Univalence},
  location     = {New York, NY, USA},
  numpages     = {29},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@InProceedings{Altenkirch2014,
  author            = {Altenkirch, Thorsten and Li, Nuo and Ondřej, Rypáček},
  date              = {2014},
  title             = {Some constructions on ω-groupoids},
  doi               = {10.1145/2631172.2631176},
  isbn              = {9781450328173},
  organization      = {Vienna, Austria},
  publisher         = {Association for Computing Machinery (ACM)},
  url               = {http://eprints.nottingham.ac.uk/id/eprint/28381},
  abstract          = {Weak ω-groupoids are the higher dimensional generalisation of setoids and are an essential ingredient of the construc- tive semantics of Homotopy Type Theory [10]. Following up on our previous formalisation [3] and Brunerie’s notes [5], we present a new formalisation of the syntax of weak ω- groupoids in Agda using heterogeneous equality. We show how to recover basic constructions on ω-groupoids using sus- pension and replacement. In particular we show that any type forms a groupoid and we outline how to derive higher dimensional composition. We present a possible semantics using globular sets and discuss the issues which arise when using globular types instead.},
  conference        = {International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP '14)},
  file              = {:Altenkirch2014 - Some Constructions on Ω Groupoids.pdf:PDF},
  groups            = {Models of TT},
  keyword           = {Logic Programming, Groupoids},
  priority          = {prio3},
  publicationstatus = {Published},
}

@Article{Takahashi1995,
  author       = {M. Takahashi},
  date         = {1995},
  journaltitle = {Information and Computation},
  title        = {Parallel Reductions in λ-Calculus},
  doi          = {10.1006/inco.1995.1057},
  issn         = {0890-5401},
  number       = {1},
  pages        = {120-127},
  url          = {https://www.sciencedirect.com/science/article/pii/S0890540185710577},
  volume       = {118},
  abstract     = {The notion of parallel reduction is extracted from the simple proof of the Church-Rosser theorem by Tait and Martin-Löf. Intuitively, this means to reduce a number of redexes (existing in a λ-term) simultaneously. Thus in the case of β-reduction the effect of a parallel reduction is same as that of a "complete development" which is defined by using "residuals" of β-redexes. A nice feature of parallel reduction, however, is that it can be defined directly by induction on the structure of λ-terms (without referring to residuals or other auxiliary notions), and the inductive definition provides us exactly what we need in proving the theorem inductively. Moreover, the notion can be easily extended to other reduction systems such as Girard′s second-order system F and Gödel′s system T. In this paper, after reevaluating the significance of the notion of parallel reduction in Tait-and-Martin-Löf type proofs of the Church-Rosser theorems, we show that the notion of parallel reduction is also useful in giving short and direct proofs of some other fundamental theorems in reduction theory of λ-calculus; among others, we give such simple proofs of the standardization theorem for β-reduction (a special case of which is known as the leftmost reduction theorem for β-reduction), the quasi-leftmost reduction theorem for β-reduction, the postponement theorem of η-reduction (in βη-reduction), and the leftmost reduction theorem for βη-reduction.},
  file         = {:Takahashi1995 - Parallel Reductions in Λ Calculus.pdf:PDF},
  groups       = {Conversion, Lambda Calculus, Eta law},
  priority     = {prio2},
}

@InProceedings{Gonthier2011,
  author    = {Gonthier, Georges},
  booktitle = {Interactive Theorem Proving},
  date      = {2011},
  title     = {Point-Free, Set-Free Concrete Linear Algebra},
  editor    = {van Eekelen, Marko and Geuvers, Herman and Schmaltz, Julien and Wiedijk, Freek},
  isbn      = {978-3-642-22863-6},
  location  = {Berlin, Heidelberg},
  pages     = {103--118},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Abstract linear algebra lets us reason and compute with collections rather than individual vectors, for example by considering entire subspaces. Its classical presentation involves a menagerie of different settheoretic objects (spaces, families, mappings), whose use often involves tedious and non-constructive pointwise reasoning; this is in stark contrast with the regularity and effectiveness of the matrix computations hiding beneath abstract linear algebra. In this paper we show how a simple variant of Gaussian elimination can be used to model abstract linear algebra directly, using matrices only to represent all categories of objects, with operations such as subspace intersection and sum. We can even provide effective support for direct sums and subalgebras. We have formalized this work in Coq, and used it to develop all of the group representation theory required for the proof of the Odd Order Theorem, including results such as the Jacobson Density Theorem, Clifford's Theorem, the Jordan-Holder Theorem for modules, theWedderburn Structure Theorem for semisimple rings (the basis for character theory).},
  file      = {:Gonthier2011 - Point Free, Set Free Concrete Linear Algebra.pdf:PDF},
  groups    = {Formalization},
  priority  = {prio3},
}

@InProceedings{Jim1996,
  author    = {Jim, Trevor},
  booktitle = {Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  date      = {1996},
  title     = {What Are Principal Typings and What Are They Good For?},
  doi       = {10.1145/237721.237728},
  isbn      = {0897917693},
  location  = {St. Petersburg Beach, Florida, USA},
  pages     = {42–53},
  publisher = {Association for Computing Machinery},
  series    = {POPL '96},
  abstract  = {We demonstrate the pragmatic value of the principal typing property, a property distinct from ML's principal type property, by studying a type system with principal typings. The type system is based on rank 2 intersection types and is closely related to ML. Its principal typing property provides elegant support for separate compilation, including "smartest recompilation" and incremental type inference. Moreover, it motivates a new rule for typing recursive definitions that can type some interesting examples of polymorphic recursion.},
  address   = {New York, NY, USA},
  file      = {:Jim1996 - What Are Principal Typings and What Are They Good For_.pdf:PDF},
  groups    = {Bidirectional Typing},
  numpages  = {12},
  priority  = {prio3},
}

@Article{McLarty2019,
  author       = {McLarty, Colin},
  date         = {2019-08},
  journaltitle = {The Review of Symbolic Logic},
  title        = {The large structures of Grothendieck founded on finite order arithmetic},
  doi          = {10.1017/s1755020319000340},
  issn         = {1755-0211},
  number       = {2},
  pages        = {296–325},
  volume       = {13},
  file         = {:McLarty2019 - The Large Structures of Grothendieck Founded on Finite Order Arithmetic.pdf:PDF},
  groups       = {Logic},
  priority     = {prio3},
  publisher    = {Cambridge University Press (CUP)},
}

@InProceedings{Gimenez1995,
  author    = {Gim{\'e}nez, Eduarde},
  booktitle = {Types for Proofs and Programs},
  date      = {1995},
  title     = {Codifying guarded definitions with recursive schemes},
  editor    = {Dybjer, Peter and Nordstr{\"o}m, Bengt and Smith, Jan},
  isbn      = {978-3-540-47770-9},
  pages     = {39--59},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We formalize an extension of the Calculus of Constructions with inductive and coinductive types which allows a more direct description of recursive definitions. The approach we follow is close to the one proposed for Martin-L{\"o}f's type theory in [5]. Recursive objects can be defined by fixed-point definitions as in functional programming languages, and a syntactical checking of these definitions avoids the introduction of non-normalizable terms. We show that the conditions for accepting a recursive definition proposed in [5] are not sufficient for the Calculus of Constructions, and we modify them. As a way of justifying our conditions, we develop a general method to codify a fix point definition satisfying them using well-known recursive schemes, like primitive recursion and co-recursion. We also propose different reduction rules from the ones used in [5] in order to obtain a decidable conversion relation for the system.},
  file      = {:Gimenez1995 - Codifying Guarded Definitions with Recursive Schemes.pdf:PDF},
  groups    = {CIC, Inductive Types, Proof Assistants},
  priority  = {prio2},
}

@PhdThesis{Cockx2017,
  author   = {Cockx, Jesper},
  date     = {2017},
  title    = {Dependent Pattern Matching and Proof-Relevant Unification},
  abstract = {Dependent type theory is a powerful language for writing functional programs with very precise types. It is used to write not only programs but also mathematical proofs that these programs satisfy certain properties. Because of this, languages based on dependent types – such as Coq, Agda, and Idris – are used both as programming languages and as interactive proof assistants. While dependent types give strong guarantees about your programs and proofs, they also impose equally strong requirements on them. This often makes it harder to write programs in a dependently typed language compared to one with a simpler type system. For this reason certain techniques have been developed, such as dependent pattern matching and specialization by unification. These techniques provide an intuitive way to write programs and proofs in dependently typed languages. Previously, dependent pattern matching had only been shown to work in a limited setting. In particular, it relied on the K axiom – also known as the uniqueness of identity proofs – to remove equations of the form x = x. This axiom is inadmissible in many type theories, particularly in the new and promising branch known as homotopy type theory (HoTT). As a result, programs and proofs in these new theories cannot make use of dependent pattern matching and are as a result much harder to write, modify, and understand. Additionally, the interaction of dependent pattern matching with small but practical features such as eta-equality for record types and postponing of unification constraints was poorly understood, resulting in subtle bugs and inconsistencies. In this thesis, we develop dependent pattern matching and unification in a general setting that does not require the K axiom, both from a theoretical perspective and a practical one. In particular, we present a proof-relevant unification algorithm, where each unification rule produces evidence of its correctness. This evidence guarantees that all unification rules are correct by construction, and also gives a computational characterization to each unification rule. To ensure that these techniques are sound and will stay so in face of future extensions to type theory, we show how to translate them to more basic primitive constructs, i.e. the standard datatype eliminators. During this translation, we pay special attention to the computational content of all constructions involved. This guarantees that the intuitions from regular pattern matching carry over to a dependently typed setting. Based on our work, we implemented a complete overhaul of the algorithm for checking definitions by dependent pattern matching in Agda. Our new implementation fixes a substantial number of issues in the old implementation, and is at the same time less restrictive than the old ad-hoc restrictions. Thus it puts the whole system back on a strong foundation. In addition, our work has already been used as the basis for other implementations of dependent pattern matching, such as the Equations package for Coq and the Lean theorem prover. The work in this thesis eliminates all implicit assumptions introduced to the type theory by pattern matching and unification. In the future, we may also want to integrate new principles with pattern matching, for example the higher inductive types introduced by HoTT. The framework presented in this thesis also provides a solid basis for such extensions to be built on.},
  file     = {:Cockx2017 - Dependent Pattern Matching and Proof Relevant Unification.pdf:PDF},
  groups   = {Proof Assistants, Inductive Types, MLTT},
  priority = {prio3},
}

@Article{Coste2001,
  author       = {Michel Coste and Henri Lombardi and Marie-Françoise Roy},
  date         = {2001},
  journaltitle = {Annals of Pure and Applied Logic},
  title        = {Dynamical method in algebra: effective Nullstellensätze},
  doi          = {10.1016/S0168-0072(01)00026-4},
  issn         = {0168-0072},
  number       = {3},
  pages        = {203-256},
  url          = {https://www.sciencedirect.com/science/article/pii/S0168007201000264},
  volume       = {111},
  abstract     = {We give a general method for producing various effective Null and Positivstellensätze, and getting new Positivstellensätze in algebraically closed valued fields and ordered groups. These various effective Nullstellensätze produce algebraic identities certifying that some geometric conditions cannot be simultaneously satisfied. We produce also constructive versions of abstract classical results of algebra based on Zorn's lemma in several cases where such constructive version did not exist. For example, the fact that a real field can be totally ordered, or the fact that a field can be embedded in an algebraically closed field. Our results are based on the concepts we develop of dynamical proofs and simultaneous collapse.},
  file         = {:Coste2001 - Dynamical Method in Algebra_ Effective Nullstellensätze.pdf:PDF},
  groups       = {Constructivism},
  keywords     = {Dyamical proof, Constructive algebra, Positivstellensatz},
  priority     = {prio3},
}

@InProceedings{Goguen2005,
  author    = {Goguen, Healfdene},
  booktitle = {Foundations of Software Science and Computational Structures},
  date      = {2005},
  title     = {Justifying Algorithms for $\beta$$\eta$-Conversion},
  editor    = {Sassone, Vladimiro},
  isbn      = {978-3-540-31982-5},
  location  = {Berlin, Heidelberg},
  pages     = {410--424},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Deciding the typing judgement of type theories with dependent types such as the Logical Framework relies on deciding the equality judgement for the same theory. Implementing the conversion algorithm for $\beta$$\eta$-equality and justifying this algorithm is therefore an important problem for applications such as proof assistants and modules systems. This article gives a proof of decidability, correctness and completeness of the conversion algorithms for $\beta$$\eta$-equality defined by Coquand [3] and Harper and Pfenning [8] for the Logical Framework, relying on established metatheoretic results for the type theory. Proofs are also given of the same properties for a typed algorithm for conversion for System F, a new result.},
  file      = {:Goguen2005 - Justifying Algorithms for beta eta Conversion.pdf:PDF},
  groups    = {Proof Assistants, Pure Type Systems, Conversion, Eta law},
  priority  = {prio1},
}

@InProceedings{Barras2005,
  author    = {Barras, Bruno and Gr{\'e}goire, Benjamin},
  booktitle = {Computer Science Logic},
  date      = {2005},
  title     = {On the Role of Type Decorations in the Calculus of Inductive Constructions},
  editor    = {Ong, Luke},
  isbn      = {978-3-540-31897-2},
  location  = {Berlin, Heidelberg},
  pages     = {151--166},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {In proof systems like Coq [16], proof-checking involves comparing types modulo $\beta$-conversion, which is potentially a time-consuming task. Significant speed-ups are achieved by compiling proof terms, see [9]. Since compilation erases some type information, we have to show that convertibility is preserved by type erasure. This article shows the equivalence of the Calculus of Inductive Constructions (formalism of Coq) and its domain-free version where parameters of inductive types are also erased. It generalizes and strengthens significantly a similar result by Barthe and S{\o}rensen [5] on the class of functional Domain-free Pure Type Systems.},
  file      = {:Barras2005 - On the Role of Type Decorations in the Calculus of Inductive Constructions.pdf:PDF},
  groups    = {Conversion, Eta law},
  priority  = {prio2},
}

@Article{Barthe2006,
  author       = {Barthe, Gilles and Coquand, Thierry},
  date         = {2006},
  journaltitle = {Journal of Functional Programming},
  title        = {Remarks on the equational theory of non-normalizing pure type systems},
  doi          = {10.1017/S0956796803004726},
  number       = {2},
  pages        = {137–155},
  volume       = {16},
  file         = {:Barthe2006 - Remarks on the Equational Theory of Non Normalizing Pure Type Systems.pdf:PDF},
  groups       = {Conversion},
  priority     = {prio1},
  publisher    = {Cambridge University Press},
}

@InProceedings{Barthe1997,
  author    = {Barthe, Gilles and S{\o}rensen, Morten Heine},
  booktitle = {Logical Foundations of Computer Science},
  date      = {1997},
  title     = {Domain-free pure type systems},
  editor    = {Adian, Sergei and Nerode, Anil},
  isbn      = {978-3-540-69065-8},
  location  = {Berlin, Heidelberg},
  pages     = {9--20},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Pure type systems feature domain-specified $\lambda$-abstractions $\lambda$x:A.M. We present a variant of pure type systems, which we call domain-free pure type systems, with domain-free $\lambda$-abstractions $\lambda$x.M. We study the basic properties of domain-free pure type systems and establish their formal relationship with pure type systems.},
  file      = {:Barthe1997 - Domain Free Pure Type Systems.pdf:PDF},
  groups    = {Eta law, Pure Type Systems},
  priority  = {prio2},
}

@Article{Abel2011,
  author       = {Andreas Abel and Thorsten Altenkirch},
  date         = {2011},
  journaltitle = {Electronic Notes in Theoretical Computer Science},
  title        = {A Partial Type Checking Algorithm for Type:Type},
  doi          = {10.1016/j.entcs.2011.02.013},
  issn         = {1571-0661},
  note         = {Proceedings of the Second Workshop on Mathematically Structured Functional Programming (MSFP 2008)},
  number       = {5},
  pages        = {3-17},
  url          = {https://www.sciencedirect.com/science/article/pii/S1571066111000508},
  volume       = {229},
  abstract     = {We analyze a partial type checking algorithm for the inconsistent domain-free pure type system Type:Type (λ⁎). We show that the algorithm is sound and partially complete using a coinductive specification of algorithmic equality. This entails that the algorithm will only diverge due to the presence of diverging computations, in particular it will terminate for all typeable terms.},
  file         = {:Abel2011 - A Partial Type Checking Algorithm for Type_Type.pdf:PDF},
  groups       = {Bidirectional Typing, Normalization, Conversion},
  keywords     = {Dependent Types, Pure Type Systems, Type Checking, Type:Type},
  priority     = {prio1},
}

@Article{Abel2007,
  author       = {Andreas Abel and Thierry Coquand},
  date         = {2007},
  journaltitle = {Fundamenta Informaticae},
  title        = {Untyped Algorithmic Equality for {Martin-L\"of's} Logical Framework with Surjective Pairs},
  note         = {{TLCA'05} special issue.},
  number       = {4},
  pages        = {345--395},
  url          = {http://fi.mimuw.edu.pl/abs77.html#15},
  volume       = {77},
  file         = {:Abel2007 - Untyped Algorithmic Equality for Martin Lof's Logical Framework with Surjective Pairs.pdf:PDF},
  groups       = {Bidirectional Typing, Conversion, Eta law, MLTT},
  priority     = {prio1},
}

@InProceedings{Abel2010,
  author    = {Andreas Abel},
  booktitle = {Functional and Logic Programming, 10th International Symposium, FLOPS 2010, Sendai, Japan, April 19-21, 2010. Proceedings},
  date      = {2010},
  title     = {Towards Normalization by Evaluation for the $\beta\eta$-Calculus of Constructions},
  doi       = {10.1007/978-3-642-12251-4},
  editor    = {Matthias Blume and Naoki Kobayashi and Germ{\'a}n Vidal},
  isbn      = {978-3-642-12250-7},
  pages     = {224--239},
  publisher = {Springer-Verlag},
  series    = {Lecture Notes in Computer Science},
  volume    = {6009},
  file      = {:Abel2010 - Towards Normalization by Evaluation for the $$ Calculus of Constructions.pdf:PDF},
  groups    = {MLTT, Normalization by evaluation},
  priority  = {prio2},
}

@Book{Pitts2013,
  author     = {Pitts, Andrew M.},
  date       = {2013},
  title      = {Nominal Sets: Names and Symmetry in Computer Science},
  doi        = {10.1017/CBO9781139084673.003},
  pages      = {1–10},
  publisher  = {Cambridge University Press},
  series     = {Cambridge Tracts in Theoretical Computer Science},
  collection = {Cambridge Tracts in Theoretical Computer Science},
  file       = {:Pitts2013 - Nominal Sets_ Names and Symmetry in Computer Science.pdf:PDF},
  groups     = {Computer Science Textbooks},
  place      = {Cambridge},
  priority   = {prio2},
}

@InProceedings{Kaestner2017,
  author      = {K{\"a}stner, Daniel and Leroy, Xavier and Blazy, Sandrine and Schommer, Bernhard and Schmidt, Michael and Ferdinand, Christian},
  booktitle   = {{SSS'17: Safety-critical Systems Symposium 2017}},
  date        = {2017-02},
  title       = {{Closing the Gap -- The Formally Verified Optimizing Compiler CompCert}},
  location    = {Bristol, United Kingdom},
  pages       = {163-180},
  publisher   = {{CreateSpace}},
  series      = {Developments in System Safety Engineering: Proceedings of the Twenty-fifth Safety-critical Systems Symposium},
  file        = {SSS2017_kaestner_et_al.pdf:https\:/hal.inria.fr/hal-01399482/file/SSS2017_kaestner_et_al.pdf:PDF},
  groups      = {Formalization},
  hal_id      = {hal-01399482},
  hal_version = {v1},
  priority    = {prio3},
}

@InProceedings{Gonthier2007,
  author    = {Georges Gonthier},
  booktitle = {Computer Mathematics, 8th Asian Symposium, {ASCM} 2007, Singapore, December 15-17, 2007. Revised and Invited Papers},
  date      = {2007},
  title     = {The Four Colour Theorem: Engineering of a Formal Proof},
  doi       = {10.1007/978-3-540-87827-8\_28},
  editor    = {Deepak Kapur},
  pages     = {333},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  url       = {https://doi.org/10.1007/978-3-540-87827-8\_28},
  volume    = {5081},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl    = {https://dblp.org/rec/conf/ascm/Gonthier07.bib},
  groups    = {Formalization},
  priority  = {prio3},
  timestamp = {Tue, 14 May 2019 10:00:48 +0200},
}

@InProceedings{Gonthier2013,
  author    = {Gonthier, Georges and Asperti, Andrea and Avigad, Jeremy and Bertot, Yves and Cohen, Cyril and Garillot, Fran{\c{c}}ois and Le Roux, St{\'e}phane and Mahboubi, Assia and O'Connor, Russell and Ould Biha, Sidi and Pasca, Ioana and Rideau, Laurence and Solovyev, Alexey and Tassi, Enrico and Th{\'e}ry, Laurent},
  booktitle = {Interactive Theorem Proving},
  date      = {2013},
  title     = {A Machine-Checked Proof of the Odd Order Theorem},
  editor    = {Blazy, Sandrine and Paulin-Mohring, Christine and Pichardie, David},
  isbn      = {978-3-642-39634-2},
  location  = {Berlin, Heidelberg},
  pages     = {163--179},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {This paper reports on a six-year collaborative effort that culminated in a complete formalization of a proof of the Feit-Thompson Odd Order Theorem in the Coq proof assistant. The formalized proof is constructive, and relies on nothing but the axioms and rules of the foundational framework implemented by Coq. To support the formalization, we developed a comprehensive set of reusable libraries of formalized mathematics, including results in finite group theory, linear algebra, Galois theory, and the theories of the real and complex algebraic numbers.},
  groups    = {Formalization},
  priority  = {prio3},
}

@Article{Bell1986,
  author       = {J. L. Bell},
  date         = {1986},
  journaltitle = {Synthese},
  title        = {From Absolute to Local Mathematics},
  doi          = {10.1007/BF00413980},
  issn         = {00397857, 15730964},
  number       = {3},
  pages        = {409--426},
  volume       = {69},
  file         = {:Bell1986 - From Absolute to Local Mathematics.pdf:PDF},
  groups       = {Constructivism, Topoi},
  priority     = {prio3},
  publisher    = {Springer},
}

@Article{Gratzer2019,
  author       = {Gratzer, Daniel and Sterling, Jonathan and Birkedal, Lars},
  date         = {2019-07},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {Implementing a Modal Dependent Type Theory},
  doi          = {10.1145/3341711},
  number       = {ICFP},
  volume       = {3},
  abstract     = {Modalities are everywhere in programming and mathematics! Despite this, however, there are still significant technical challenges in formulating a core dependent type theory with modalities. We present a dependent type theory MLTT🔒 supporting the connectives of standard Martin-L\"{o}f Type Theory as well as an S4-style necessity operator. MLTT🔒 supports a smooth interaction between modal and dependent types and provides a common basis for the use of modalities in programming and in synthetic mathematics. We design and prove the soundness and completeness of a type checking algorithm for MLTT🔒, using a novel extension of normalization by evaluation. We have also implemented our algorithm in a prototype proof assistant for MLTT🔒, demonstrating the ease of applying our techniques.},
  articleno    = {107},
  file         = {:Gratzer2019 - Implementing a Modal Dependent Type Theory.pdf:PDF},
  groups       = {Normalization by evaluation, Bidirectional Typing},
  issue_date   = {August 2019},
  keywords     = {normalization by evaluation, Modal types, type-checking, dependent types},
  location     = {New York, NY, USA},
  numpages     = {29},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@Article{Wiedijk2012,
  author       = {Freek Wiedijk},
  date         = {2012},
  journaltitle = {Electronic Notes in Theoretical Computer Science},
  title        = {Pollack-inconsistency},
  doi          = {10.1016/j.entcs.2012.06.008},
  issn         = {1571-0661},
  note         = {Proceedings of the 9th International Workshop On User Interfaces for Theorem Provers (UITP10)},
  pages        = {85-100},
  volume       = {285},
  abstract     = {For interactive theorem provers a very desirable property is consistency: it should not be possible to prove false theorems. However, this is not enough: it also should not be possible to think that a theorem that actually is false has been proved. More precisely: the user should be able to know what it is that the interactive theorem prover is proving. To make these issues concrete we introduce the notion of Pollack-consistency. This property is related to a system being able to correctly parse formulas that it printed itself. In current systems it happens regularly that this fails. We argue that a good interactive theorem prover should be Pollack-consistent. We show with examples that many interactive theorem provers currently are not Pollack-consistent. Finally we describe a simple approach for making a system Pollack-consistent, which only consists of a small modification to the printing code of the system.},
  file         = {:Wiedijk2012 - Pollack Inconsistency.pdf:PDF},
  groups       = {Proof Assistants},
  keywords     = {Interactive theorem prover, consistency, Pollack consistency},
  priority     = {prio3},
}

@InProceedings{Levy2017,
  author    = {Levy, Paul Blain},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  date      = {2017},
  title     = {Contextual Isomorphisms},
  doi       = {10.1145/3009837.3009898},
  isbn      = {9781450346603},
  location  = {Paris, France},
  pages     = {400–414},
  publisher = {Association for Computing Machinery},
  series    = {POPL 2017},
  abstract  = {What is the right notion of "isomorphism" between types, in a simple type theory? The traditional answer is: a pair of terms that are inverse up to a specified congruence. We firstly argue that, in the presence of effects, this answer is too liberal and needs to be restricted, using F\"{u}hrmann's notion of thunkability in the case of value types (as in call-by-value), or using Munch-Maccagnoni's notion of linearity in the case of computation types (as in call-by-name). Yet that leaves us with different notions of isomorphism for different kinds of type. This situation is resolved by means of a new notion of "contextual" isomorphism (or morphism), analogous at the level of types to contextual equivalence of terms. A contextual morphism is a way of replacing one type with the other wherever it may occur in a judgement, in a way that is preserved by the action of any term with holes. For types of pure λ-calculus, we show that a contextual morphism corresponds to a traditional isomorphism. For value types, a contextual morphism corresponds to a thunkable isomorphism, and for computation types, to a linear isomorphism.},
  address   = {New York, NY, USA},
  file      = {:Levy2017 - Contextual Isomorphisms.pdf:PDF},
  groups    = {Effects},
  keywords  = {computational effects, call-by-push-value, contextual equivalence, isomorphism},
  numpages  = {15},
  priority  = {prio3},
}

@Article{Siles2012,
  author       = {Vincent Siles and Hugo Herbelin},
  date         = {2012},
  journaltitle = {J. Funct. Program.},
  title        = {Pure Type System conversion is always typable},
  doi          = {10.1017/S0956796812000044},
  number       = {2},
  pages        = {153--180},
  volume       = {22},
  file         = {:Siles2012 - Pure Type System Conversion Is Always Typable.pdf:PDF},
  groups       = {Conversion, Pure Type Systems},
  priority     = {prio2},
  timestamp    = {Sat, 27 May 2017 14:24:34 +0200},
}

@InProceedings{Siles2010a,
  author    = {Vincent Siles and Hugo Herbelin},
  booktitle = {Proceedings of the 25th Annual {IEEE} Symposium on Logic in Computer Science, {LICS} 2010, 11-14 July 2010, Edinburgh, United Kingdom},
  date      = {2010},
  title     = {Equality Is Typable in Semi-full Pure Type Systems},
  doi       = {10.1109/LICS.2010.19},
  pages     = {21--30},
  publisher = {{IEEE} Computer Society},
  file      = {:Siles2010a - Equality Is Typable in Semi Full Pure Type Systems.pdf:PDF},
  groups    = {Conversion},
  priority  = {prio2},
  timestamp = {Wed, 16 Oct 2019 14:14:54 +0200},
}

@Article{Adams2006,
  author       = {Robin Adams},
  date         = {2006},
  journaltitle = {J. Funct. Program.},
  title        = {Pure type systems with judgemental equality},
  doi          = {10.1017/S0956796805005770},
  number       = {2},
  pages        = {219--246},
  volume       = {16},
  file         = {:Adams2006 - Pure Type Systems with Judgemental Equality.pdf:PDF},
  groups       = {Conversion, Pure Type Systems},
  priority     = {prio2},
  timestamp    = {Fri, 02 Nov 2018 09:31:48 +0100},
}

@Eprint{Sterling2021,
  author      = {Jonathan Sterling and Carlo Angiuli},
  date        = {2021},
  title       = {Normalization for Cubical Type Theory},
  eprint      = {2101.11479},
  eprintclass = {cs.LO},
  eprinttype  = {arXiv},
  note        = {arXiv preprint},
  file        = {:Sterling2021 - Normalization for Cubical Type Theory.pdf:PDF},
  groups      = {Normalization by evaluation},
  priority    = {prio3},
}

@PhdThesis{Cohen2012,
  author      = {Cohen, Cyril},
  date        = {2012},
  institution = {{\'E}cole polytechnique},
  title       = {{Formalized algebraic numbers: construction and first-order theory}},
  language    = {English},
  url         = {http://perso.crans.org/cohen/papers/thesis.pdf},
  affiliation = {Laboratoire d'informatique de l'{\'E}cole polytechnique - LIX, INRIA Saclay - Ile de France, Microsoft Research - Inria Joint Centre},
  file        = {:Cohen2012 - Formalized Algebraic Numbers_ Construction and First Order Theory.pdf:PDF;thesis.pdf:http\:/perso.crans.org/cohen/papers/thesis.pdf:PDF},
  groups      = {Formalization},
  keywords    = {Coq; Formal proofs; Formalization of mathematics; Small scale reflection; Algebraic numbers; Constructive mathematics; Quantifier elimination; Real numbers},
  priority    = {prio3},
}

@PhdThesis{Ringer2021,
  author      = {Ringer, Talia},
  date        = {2021},
  institution = {University of Washington},
  title       = {Proof Repair},
  file        = {:Ringer2021 - Proof Repair.pdf:PDF},
  groups      = {Proof Assistants},
  priority    = {prio3},
}

@Book{Danvy1998,
  date      = {1998},
  title     = {Proceedings of the 1998 APPSEM Workshop on Normalization by Evaluation},
  editor    = {Olivier Danvy and Peter Dybjer},
  language  = {English},
  number    = {NS-98-1},
  publisher = {Department of Computer Science, Aarhus University},
  series    = {BRICS},
  file      = {:Danvy1998 - Proceedings of the 1998 APPSEM Workshop on Normalization by Evaluation.pdf:PDF},
  groups    = {Normalization by evaluation},
  priority  = {prio3},
}

@InProceedings{LennonBertrand2021,
  author     = {Lennon-Bertrand, Meven},
  booktitle  = {12th International Conference on Interactive Theorem Proving (ITP 2021)},
  date       = {2021},
  title      = {{Complete Bidirectional Typing for the Calculus of Inductive Constructions}},
  doi        = {10.4230/LIPIcs.ITP.2021.24},
  editor     = {Cohen, Liron and Kaliszyk, Cezary},
  isbn       = {978-3-95977-188-7},
  publisher  = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  series     = {Leibniz International Proceedings in Informatics (LIPIcs)},
  url        = {https://drops.dagstuhl.de/opus/volltexte/2021/13919},
  volume     = {193},
  annotation = {Keywords: Bidirectional Typing, Calculus of Inductive Constructions, Coq, Proof Assistants},
  file       = {:LennonBertrand2021 - Complete Bidirectional Typing for the Calculus of Inductive Constructions.pdf:PDF},
  groups     = {Bidirectional Typing, CIC, MetaCoq},
  issn       = {1868-8969},
  priority   = {prio3},
  urn        = {urn:nbn:de:0030-drops-139194},
}

@Book{Mahboubi2021,
  author    = {Assia Mahboubi and Enrico Tassi},
  date      = {2021-01},
  title     = {Mathematical Components},
  doi       = {10.5281/zenodo.4457887},
  publisher = {Zenodo},
  file      = {:Mahboubi2021 - Mathematical Components.pdf:PDF},
  groups    = {Computer Science Textbooks, Formalization},
  priority  = {prio3},
}

@Article{Altenkirch2015,
  author       = {Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and McBride, Conor and Morris, Peter},
  date         = {2015},
  journaltitle = {Journal of Functional Programming},
  title        = {Indexed containers},
  pages        = {e5},
  volume       = {25},
  file         = {:Altenkirch2015 - Indexed Containers.pdf:PDF},
  groups       = {Inductive Types},
  priority     = {prio2},
  publisher    = {Cambridge University Press},
}

@TechReport{Rossum2014,
  author      = {van Rossum, Guido and Lehtosalo, Jukka and Langa, Łukasz},
  date        = {2014},
  institution = {The Python Software Foundation},
  title       = {PEP 484 – Type Hints},
  url         = {https://www.python.org/dev/peps/pep-0484/},
  groups      = {Gradual Typing, meven:5},
  priority    = {prio3},
}

@InProceedings{Awodey2012,
  author    = {Awodey, Steve and Gambino, Nicola and Sojakova, Kristina},
  booktitle = {Proceedings of the 2012 27th Annual IEEE/ACM Symposium on Logic in Computer Science},
  date      = {2012},
  title     = {Inductive Types in Homotopy Type Theory},
  doi       = {10.1109/LICS.2012.21},
  isbn      = {9780769547695},
  pages     = {95–104},
  publisher = {IEEE Computer Society},
  series    = {LICS '12},
  abstract  = {Homotopy type theory is an interpretation of Martin-L\"{o}f's constructive type theory
into abstract homotopy theory. There results a link between constructive mathematics
and algebraic topology, providing topological semantics for intensional systems of
type theory as well as a computational approach to algebraic topology via type theory-based
proof assistants such as Coq. The present work investigates inductive types in this
setting. Modified rules for inductive types, including types of well-founded trees,
or W-types, are presented, and the basic homotopical semantics of such types are determined.
Proofs of all results have been formally verified by the Coq proof assistant, and
the proof scripts for this verification form an essential component of this research.},
  file      = {:Awodey2012 - Inductive Types in Homotopy Type Theory.pdf:PDF},
  groups    = {Inductive Types, HoTT},
  keywords  = {initial algebras, homotopy theory, Type theory},
  numpages  = {10},
  priority  = {prio3},
}

@Article{MartinLoef2006,
  author       = {Martin-Löf, Per},
  date         = {2006-02},
  journaltitle = {The Computer Journal},
  title        = {{100 years of Zermelo's axiom of choice: what was the problem with it?}},
  doi          = {10.1093/comjnl/bxh162},
  issn         = {0010-4620},
  number       = {3},
  pages        = {345-350},
  volume       = {49},
  abstract     = {{In February 2005 the Third Annual University of London Kolmogorov Lecture was held at Royal Holloway. These annual lectures were established in 2003. The lecture was given by Professor Per Martin-Löf of Stockholm University—one of the world's foremost researchers in the field of constructive mathematics. Professor Martin-Löf was presented with the Kolmogorov Lecture medal in recognition of his contribution to mathematical logic.Professor Alex Gammerman, Director of Royal Holloway's Computer Learning Research Centre, said: ‘The annual lectures are devoted to Andrei Nikolaevich Kolmogorov (1903–1987) who was one of the foremost Soviet mathematicians of the Twentieth Century. He was active in many mathematical fields, with interests in both theory and application. The work of Kolmogorov is the basis of Complexity Science: he made one of the most beautiful discoveries of the 20th century—what is now known as Kolmogorov Complexity or Algorithmic Information Theory. This discovery is crucial to the great advances currently being made in machine learning, and particularly here at Royal Holloway's world-renowned Computer Learning Research Centre. We have established the annual Kolmogorov Lecture to acknowledge the profound importance of his research. For many years A. N. Kolmogorov was head of the mathematical logic department at Moscow State University, and Per Martin-Löf studied under his supervision in 1964–65’.}},
  file         = {:MartinLoef2006 - 100 Years of Zermelo's Axiom of Choice_ What Was the Problem with It_.pdf:PDF},
  groups       = {Constructivism},
  priority     = {prio3},
}

@InProceedings{Cimini2016,
  author    = {Cimini, Matteo and Siek, Jeremy G.},
  booktitle = {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  date      = {2016},
  title     = {The Gradualizer: A Methodology and Algorithm for Generating Gradual Type Systems},
  doi       = {10.1145/2837614.2837632},
  isbn      = {9781450335492},
  location  = {St. Petersburg, FL, USA},
  pages     = {443–455},
  publisher = {Association for Computing Machinery},
  series    = {POPL '16},
  abstract  = {Many languages are beginning to integrate dynamic and static typing. Siek and Taha
offered gradual typing as an approach to this integration that provides a coherent
and full-span migration between the two disciplines. However, the literature lacks
a general methodology for designing gradually typed languages. Our first contribution
is to provide a methodology for deriving the gradual type system and the compilation
to the cast calculus. Based on this methodology, we present the Gradualizer, an algorithm
that generates a gradual type system from a well-formed type system and also generates
a compiler to the cast calculus. Our algorithm handles a large class of type systems
and generates systems that are correct with respect to the formal criteria of gradual
typing. We also report on an implementation of the Gradualizer that takes a type system
expressed in lambda-prolog and outputs its gradually typed version and a compiler
to the cast calculus in lambda-prolog.},
  file      = {:Cimini2016 - The Gradualizer_ a Methodology and Algorithm for Generating Gradual Type Systems.pdf:PDF},
  groups    = {Gradual Typing},
  keywords  = {semantics, type systems, gradual typing, methodology},
  numpages  = {13},
  priority  = {prio3},
}

@Article{Blass1983,
  author       = {A. Blass},
  date         = {1983},
  journaltitle = {Fundamenta Mathematicae},
  title        = {Words, free algebras, and coequalizers},
  pages        = {117-160},
  volume       = {117},
  comment      = {In the right context, the existence of initial universal algebras is logically stronger than the existence of initial free universal algebras (ie. without equalities).
So having QITs should be logically stronger than having only regular inductive types.},
  file         = {:Blass1983 - Words, Free Algebras, and Coequalizers.pdf:PDF},
  groups       = {Inductive Types},
  priority     = {prio3},
}

@InProceedings{Coquand1992,
  author    = {Thierry Coquand},
  booktitle = {Proceedings of the Workshop on Types for Proofs and Programs, B{\aa}stad, Sweden},
  date      = {1992-06},
  title     = {Pattern Matching with Dependent Types},
  editor    = {Bengt Nordstr\"om and Kent Petersson and Gordon Plotkin},
  pages     = {71-–83},
  file      = {:Coquand1992 - Pattern Matching with Dependent Types.ps:PostScript},
  groups    = {Inductive Types, MLTT},
  priority  = {prio2},
}

@InProceedings{Goguen2006,
  author    = {Healfdene Goguen and Conor McBride and James McKinna},
  booktitle = {Algebra, Meaning, and Computation, Essays Dedicated to Joseph A. Goguen on the Occasion of His 65th Birthday},
  date      = {2006},
  title     = {Eliminating Dependent Pattern Matching},
  doi       = {10.1007/11780274_27},
  editor    = {Kokichi Futatsugi and Jean{-}Pierre Jouannaud and Jos{\'{e}} Meseguer},
  isbn      = {3-540-35462-X},
  pages     = {521--540},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {4060},
  file      = {:Goguen2006 - Eliminating Dependent Pattern Matching.pdf:PDF},
  groups    = {Inductive Types},
  priority  = {prio2},
}

@Article{Sozeau2019a,
  author       = {Sozeau, Matthieu and Mangin, Cyprien},
  date         = {2019-07},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {Equations Reloaded: High-Level Dependently-Typed Functional Programming and Proving in Coq},
  doi          = {10.1145/3341690},
  number       = {ICFP},
  volume       = {3},
  abstract     = {Equations is a plugin for the Coq proof assistant which provides a notation for defining
programs by dependent pattern-matching and structural or well-founded recursion. It
additionally derives useful high-level proof principles for demonstrating properties
about them, abstracting away from the implementation details of the function and its
compiled form. We present a general design and implementation that provides a robust
and expressive function definition package as a definitional extension to the Coq
kernel. At the core of the system is a new simplifier for dependent equalities based
on an original handling of the no-confusion property of constructors.},
  articleno    = {86},
  file         = {:Sozeau2019a - Equations Reloaded_ High Level Dependently Typed Functional Programming and Proving in Coq.pdf:PDF},
  groups       = {Proof Assistants, Inductive Types},
  issue_date   = {August 2019},
  keywords     = {recursion, dependent pattern-matching, proof assistants},
  location     = {New York, NY, USA},
  numpages     = {29},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@PhdThesis{Winterhalter2020,
  author      = {Winterhalter, Théo},
  date        = {2020},
  institution = {Université de Nantes},
  title       = {Formalisation and meta-theory of type theory},
  file        = {:TheoWinterhalter-PhD-v1.2.1.pdf:PDF},
  groups      = {MetaCoq},
  priority    = {prio3},
}

@Book{Chlipala2013,
  author    = {Chlipala, Adam},
  date      = {2013-12},
  title     = {{Certified Programming with Dependent Types: A Pragmatic Introduction to the Coq Proof Assistant}},
  doi       = {10.7551/mitpress/9153.001.0001},
  isbn      = {9780262317870},
  publisher = {The MIT Press},
  abstract  = {{A handbook to the Coq software for writing and checking mathematical proofs, with a practical engineering focus.The technology of mechanized program verification can play a supporting role in many kinds of research projects in computer science, and related tools for formal proof-checking are seeing increasing adoption in mathematics and engineering. This book provides an introduction to the Coq software for writing and checking mathematical proofs. It takes a practical engineering focus throughout, emphasizing techniques that will help users to build, understand, and maintain large Coq developments and minimize the cost of code change over time.Two topics, rarely discussed elsewhere, are covered in detail: effective dependently typed programming (making productive use of a feature at the heart of the Coq system) and construction of domain-specific proof tactics. Almost every subject covered is also relevant to interactive computer theorem proving in general, not just program verification, demonstrated through examples of verified programs applied in many different sorts of formalizations. The book develops a unique automated proof style and applies it throughout; even experienced Coq users may benefit from reading about basic Coq concepts from this novel perspective. The book also offers a library of tactics, or programs that find proofs, designed for use with examples in the book. Readers will acquire the necessary skills to reimplement these tactics in other settings by the end of the book. All of the code appearing in the book is freely available online.}},
  groups    = {Formalization, Computer Science Textbooks},
  priority  = {prio3},
}

@Article{Lee2011,
  author       = {Gyesik Lee and Benjamin Werner},
  date         = {2011-11},
  journaltitle = {{Logical Methods in Computer Science}},
  title        = {{Proof-irrelevant model of CC with predicative induction and judgmental equality}},
  doi          = {10.2168/LMCS-7(4:5)2011},
  url          = {https://lmcs.episciences.org/920},
  volume       = {{Volume 7, Issue 4}},
  comment      = {The paper cited for eta in Coq 8.4 release notes.},
  file         = {:Lee2011 - Proof Irrelevant Model of CC with Predicative Induction and Judgmental Equality.pdf:PDF},
  groups       = {Conversion},
  keywords     = {Computer Science - Logic in Computer Science ; F.4.1, F.3.1},
  priority     = {prio2},
}

@InProceedings{Allais2013,
  author    = {Allais, Guillaume and McBride, Conor and Boutillier, Pierre},
  booktitle = {Proceedings of the 2013 ACM SIGPLAN Workshop on Dependently-Typed Programming},
  date      = {2013},
  title     = {New Equations for Neutral Terms: A Sound and Complete Decision Procedure, Formalized},
  doi       = {10.1145/2502409.2502411},
  isbn      = {9781450323840},
  location  = {Boston, Massachusetts, USA},
  pages     = {13–24},
  publisher = {Association for Computing Machinery},
  series    = {DTP '13},
  abstract  = {The definitional equality of an intensional type theory is its test of type compatibility. Today's systems rely on ordinary evaluation semantics to compare expressions in types, frustrating users with type errors arising when evaluation fails to identify two `obviously' equal terms. If only the machine could decide a richer theory! We propose a way to decide theories which supplement evaluation with `ν-rules', rearranging the neutral parts of normal forms, and report a successful initial experiment.We study a simple λ-calculus with primitive fold, map and append operations on lists and develop in Agda a sound and complete decision procedure for an equational theory enriched with monoid, functor and fusion laws.},
  address   = {New York, NY, USA},
  file      = {:Allais2013 - New Equations for Neutral Terms_ a Sound and Complete Decision Procedure, Formalized.pdf:PDF},
  groups    = {Conversion},
  keywords  = {simply typed lambda calculus, map fusion, logical relations, normalization by evaluation},
  numpages  = {12},
  priority  = {prio2},
}

@InBook{Palmgren1998,
  author    = {Palmgren, Erik},
  booktitle = {Twenty Five Years of Constructive Type Theory},
  date      = {1998},
  title     = {On universes in type theory},
  doi       = {10.1093/oso/9780198501275.003.0012},
  language  = {eng},
  publisher = {Oxford University Press},
  abstract  = {The notion of a universe of types was introduced into constructive type theory by Martin-L{\"o}f (1975). According to the propositions-as-types principle inherent in type theory, the notion plays two roles. The first is as a collection of sets or types closed under certain type constructions. The second is as a set of constructively given infinitary formulas. In this paper we discuss the notion of universe in type theory and suggest and study some useful extensions. We assume familiarity with type theory as presented in, for example, Martin-L{\"o}f (1984). Universes have been effective in expanding the realm of constructivism. One example is constructive category theory where type universes take the roles of Grothendieck universes of sets, in handling large categories. A more profound example is Aczel's (1986) type-theoretic interpretation of constructive set theory (CZF). It is done by coding ϵ-diagrams into well-order types, with branching over an arbitrary type of the universe. The latter generality is crucial for interpreting the separation axiom. The introduction of universes and well-orders (W-types) in conjunction gives a great proof-theoretic strength. This has provided constructive justification of strong subsystems of second-order arithmetic studied by proof-theorists (see Griffor and Rathjen (1994) and Setzer (1993), and for some early results, see Palmgren (1992)). At present, it appears that the most easily justifiable way to increase the proof-theoretic strength of type theory is to introduce ever more powerful universe constructions. We will give two such extensions in this paper. Besides contributing to the understanding of subsystems of second-order arithmetic and pushing the limits of inductive definability, such constructions provide intuitionistic analogues of large cardinals (Rathjen et al, in press). A third new use of universes is to facilitate the incorporation of classical reasoning into constructive type theory. We introduce a universe of classical propositions and prove a conservation result for `$\Pi$-formulas'. Extracting programs from classical proofs is then tractable within type theory. The next section gives an introduction to the notion of universe. The central part of the paper is section 3 where we introduce a universe forming operator and a super universe closed under this operator. ER},
  file      = {:Palmgren1998 - On Universes in Type Theory.pdf:PDF},
  groups    = {Cumulativity},
  priority  = {prio2},
}

@Article{Jay1996,
  author       = {Barry Jay and Neil Ghani},
  date         = {1996},
  journaltitle = {Journal of Functional Programming},
  title        = {The Virtues of Eta-Expansion},
  number       = {2},
  pages        = {135-154},
  volume       = {5},
  file         = {:Jay1996 - The Virtues of Eta Expansion.pdf:PDF},
  groups       = {Eta law},
  priority     = {prio3},
}

@InProceedings{Johann2022,
  author    = {Johann, Patricia and Ghiorzi, Enrico},
  booktitle = {Proceedings of the 11th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  date      = {2022},
  title     = {(Deep) Induction Rules for GADTs},
  doi       = {10.1145/3497775.3503680},
  isbn      = {9781450391825},
  location  = {Philadelphia, PA, USA},
  pages     = {324–337},
  publisher = {Association for Computing Machinery},
  series    = {CPP 2022},
  abstract  = {Deep data types are those that are constructed from other data types, including, possibly, themselves. In this case, they are said to be truly nested. Deep induction is an extension of structural induction that traverses all of the structure in a deep data type, propagating predicates on its primitive data throughout the entire structure. Deep induction can be used to prove properties of nested types, including truly nested types, that cannot be proved via structural induction. In this paper we show how to extend deep induction to GADTs that are not truly nested GADTs. This opens the way to incorporating automatic generation of (deep) induction rules for them into proof assistants. We also show that the techniques developed in this paper do not suffice for extending deep induction to truly nested GADTs, so more sophisticated techniques are needed to derive deep induction rules for them.},
  file      = {:Johann2022 - (Deep) Induction Rules for GADTs.pdf:PDF},
  groups    = {Inductive Types},
  keywords  = {induction, GADTs, proof assistants},
  numpages  = {14},
  priority  = {prio1},
}

@InProceedings{Donato2022,
  author    = {Donato, Pablo and Strub, Pierre-Yves and Werner, Benjamin},
  booktitle = {Proceedings of the 11th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  date      = {2022},
  title     = {A Drag-and-Drop Proof Tactic},
  doi       = {10.1145/3497775.3503692},
  isbn      = {9781450391825},
  location  = {Philadelphia, PA, USA},
  pages     = {197–209},
  publisher = {Association for Computing Machinery},
  series    = {CPP 2022},
  abstract  = {We explore the features of a user interface where formal proofs can be built through gestural actions. In particular, we show how proof construction steps can be associated to drag-and-drop actions. We argue that this can provide quick and intuitive proof construction steps. This work builds on theoretical tools coming from deep inference. It also resumes and integrates some ideas of the former proof-by-pointing project.},
  file      = {:Donato2022 - A Drag and Drop Proof Tactic.pdf:PDF},
  groups    = {Proof Assistants},
  keywords  = {logic, deep inference, user interfaces, formal proofs},
  numpages  = {13},
  priority  = {prio2},
}

@Misc{bocquet2020coherence,
  author      = {Rafaël Bocquet},
  date        = {2020},
  title       = {Coherence of strict equalities in dependent type theories},
  eprint      = {2010.14166},
  eprintclass = {cs.LO},
  eprinttype  = {arXiv},
  groups      = {Conversion},
  priority    = {prio2},
}

@InProceedings{Chapman2010,
  author    = {Chapman, James and Dagand, Pierre-\'{E}variste and McBride, Conor and Morris, Peter},
  booktitle = {Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming},
  date      = {2010},
  title     = {The Gentle Art of Levitation},
  doi       = {10.1145/1863543.1863547},
  isbn      = {978-1-60558-794-3},
  location  = {Baltimore, Maryland, USA},
  pages     = {3--14},
  publisher = {ACM},
  series    = {ICFP '10},
  acmid     = {1863547},
  address   = {New York, NY, USA},
  file      = {:Chapman2010 - The Gentle Art of Levitation.pdf:PDF},
  groups    = {Inductive Types},
  keywords  = {data structure, metaprogramming, monads, proof assistants, type systems},
  numpages  = {12},
  priority  = {prio2},
}

@Unpublished{Carneiro2019,
  author   = {Mario Carneiro},
  date     = {2019},
  title    = {The Type Theory of Lean},
  note     = {Master Thesis},
  url      = {https://github.com/digama0/lean-type-theory},
  file     = {:Carneiro2019 - The Type Theory of Lean.pdf:PDF},
  groups   = {Proof Assistants},
  priority = {prio2},
}

@Article{MacQueen2020,
  author       = {MacQueen, David and Harper, Robert and Reppy, John},
  date         = {2020-06},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {The History of Standard ML},
  doi          = {10.1145/3386336},
  number       = {HOPL},
  volume       = {4},
  abstract     = {The ML family of strict functional languages, which includes F#, OCaml, and Standard ML, evolved from the Meta Language of the LCF theorem proving system developed by Robin Milner and his research group at the University of Edinburgh in the 1970s. This paper focuses on the history of Standard ML, which plays a central role in this family of languages, as it was the first to include the complete set of features that we now associate with the name “ML” (i.e., polymorphic type inference, datatypes with pattern matching, modules, exceptions, and mutable state). Standard ML, and the ML family of languages, have had enormous influence on the world of programming language design and theory. ML is the foremost exemplar of a functional programming language with strict evaluation (call-by-value) and static typing. The use of parametric polymorphism in its type system, together with the automatic inference of such types, has influenced a wide variety of modern languages (where polymorphism is often referred to as generics). It has popularized the idea of datatypes with associated case analysis by pattern matching. The module system of Standard ML extends the notion of type-level parameterization to large-scale programming with the notion of parametric modules, or functors. Standard ML also set a precedent by being a language whose design included a formal definition with an associated metatheory of mathematical proofs (such as soundness of the type system). A formal definition was one of the explicit goals from the beginning of the project. While some previous languages had rigorous definitions, these definitions were not integral to the design process, and the formal part was limited to the language syntax and possibly dynamic semantics or static semantics, but not both. The paper covers the early history of ML, the subsequent efforts to define a standard ML language, and the development of its major features and its formal definition. We also review the impact that the language had on programming-language research.},
  articleno    = {86},
  file         = {:MacQueen2020 - The History of Standard ML.pdf:PDF},
  issue_date   = {June 2020},
  keywords     = {Operational semantics, Standard ML, Type checking, Language design},
  location     = {New York, NY, USA},
  numpages     = {100},
  priority     = {prio2},
  publisher    = {Association for Computing Machinery},
}

@InProceedings{Cockx2020,
  author     = {Jesper Cockx},
  booktitle  = {25th International Conference on Types for Proofs and Programs (TYPES 2019)},
  date       = {2020},
  title      = {{Type Theory Unchained: Extending Agda with User-Defined Rewrite Rules}},
  doi        = {10.4230/LIPIcs.TYPES.2019.2},
  editor     = {Marc Bezem and Assia Mahboubi},
  isbn       = {978-3-95977-158-0},
  location   = {Dagstuhl, Germany},
  pages      = {2:1--2:27},
  publisher  = {Schloss Dagstuhl--Leibniz-Zentrum f{\"u}r Informatik},
  series     = {Leibniz International Proceedings in Informatics (LIPIcs)},
  url        = {https://drops.dagstuhl.de/opus/volltexte/2020/13066},
  volume     = {175},
  annotation = {Keywords: Dependent types, Proof assistants, Rewrite rules, Higher-order rewriting, Agda},
  file       = {:Cockx2020 - Type Theory Unchained_ Extending Agda with User Defined Rewrite Rules.pdf:PDF},
  groups     = {Proof Assistants, MLTT},
  issn       = {1868-8969},
  priority   = {prio3},
  urn        = {urn:nbn:de:0030-drops-130666},
}

@Article{Bauer2022,
  author       = {Andrej Bauer and Anja Petković Komel},
  date         = {2022-01},
  journaltitle = {{Logical Methods in Computer Science}},
  title        = {{An extensible equality checking algorithm for dependent type theories}},
  doi          = {10.46298/lmcs-18(1:17)2022},
  url          = {https://lmcs.episciences.org/8980},
  volume       = {{Volume 18, Issue 1}},
  file         = {:Bauer2022 - An Extensible Equality Checking Algorithm for Dependent Type Theories.pdf:PDF},
  groups       = {Conversion, Irrelevance},
  keywords     = {Computer Science - Logic in Computer Science ; Mathematics - Logic ; 03B38 (Primary), 68Q42 (Secondary) ; F.4.1},
  priority     = {prio1},
}

@PhdThesis{Dagand2013,
  author      = {Dagand, Pierre-Evariste},
  date        = {2013},
  institution = {University of Strathclyde},
  title       = {Reusability and Dependent Types},
  file        = {:Dagand2013 - Reusability and Dependent Types.pdf:PDF},
  groups      = {Inductive Types, Dependent types},
  priority    = {prio2},
}

@InProceedings{Lemay2021,
  author    = {Lemay, Marc and Fu, Qiancheng and Xi, Hongwei},
  booktitle = {Proceedings of the 6th ACM SIGPLAN International Workshop on Type-Driven Development},
  date      = {2021},
  title     = {Gradual Correctness: a Dynamically BidirectionalFull-Spectrum Dependent Type Theory},
  publisher = {Association for Computing Machinery},
  series    = {TyDe 2021},
  comment   = {Strange version of GCIC with no ?, unplugged conversion (in favour of only runtime checks) and blames.},
  file      = {:Lemay2021 - Gradual Correctness_ a Dynamically BidirectionalFull Spectrum Dependent Type Theory.pdf:PDF},
  groups    = {Gradual Typing},
  priority  = {prio3},
}

@Article{Pujet2022,
  author       = {Pujet, Lo\"{\i}c and Tabareau, Nicolas},
  date         = {2022-01},
  journaltitle = {Proc. ACM Program. Lang.},
  title        = {Observational Equality: Now for Good},
  doi          = {10.1145/3498693},
  number       = {POPL},
  volume       = {6},
  abstract     = {Building on the recent extension of dependent type theory with a universe of definitionally proof-irrelevant types, we introduce TTobs, a new type theory based on the setoidal interpretation of dependent type theory. TTobs equips every type with an identity relation that satisfies function extensionality, propositional extensionality, and definitional uniqueness of identity proofs (UIP). Compared to other existing proposals to enrich dependent type theory with these principles, our theory features a notion of reduction that is normalizing and provides an algorithmic canonicity result, which we formally prove in Agda using the logical relation framework of Abel et al. Our paper thoroughly develops the meta-theoretical properties of TTobs, such as the decidability of the conversion and of the type checking, as well as consistency. We also explain how to extend our theory with quotient types, and we introduce a setoidal version of Swan's Id types that turn it into a proper extension of MLTT with inductive equality.},
  articleno    = {32},
  file         = {:Pujet2022 - Observational Equality_ Now for Good.pdf:PDF},
  issue_date   = {January 2022},
  keywords     = {dependent types, confluence, rewriting theory, type theory, termination},
  location     = {New York, NY, USA},
  numpages     = {27},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@Book{Begriffsschrift,
  author     = {Gottlob Frege},
  date       = {1879},
  title      = {Begriffsschrift: Eine der Arithmetischen Nachgebildete Formelsprache des Reinen Denkens},
  publisher  = {Halle a.d.S.: Louis Nebert},
  groups     = {History},
  priority   = {prio3},
  shorttitle = {Begriffsschift},
}

@Book{Hales2012,
  author     = {Hales, Thomas},
  date       = {2012},
  title      = {Dense Sphere Packings: A Blueprint for Formal Proofs},
  doi        = {10.1017/CBO9781139193894.001},
  publisher  = {Cambridge University Press},
  series     = {London Mathematical Society Lecture Note Series},
  collection = {London Mathematical Society Lecture Note Series},
  file       = {:Hales2012 - Dense Sphere Packings_ a Blueprint for Formal Proofs.pdf:PDF},
  groups     = {History},
  place      = {Cambridge},
  priority   = {prio3},
}

@Article{Milner1978,
  author       = {Robin Milner},
  date         = {1978},
  journaltitle = {Journal of Computer and System Sciences},
  title        = {A theory of type polymorphism in programming},
  doi          = {10.1016/0022-0000(78)90014-4},
  issn         = {0022-0000},
  number       = {3},
  pages        = {348-375},
  url          = {https://www.sciencedirect.com/science/article/pii/0022000078900144},
  volume       = {17},
  abstract     = {The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm W which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot “go wrong” and a Syntactic Soundness Theorem states that if W accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on W is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system.},
  file         = {:Milner1978 - A Theory of Type Polymorphism in Programming.pdf:PDF},
  priority     = {prio3},
}

@InCollection{Barendregt2001,
  author    = {Henk Barendregt and Herman Geuvers},
  booktitle = {Handbook of Automated Reasoning},
  date      = {2001},
  title     = {Proof-Assistants Using Dependent Type Systems},
  doi       = {10.1016/B978-044450813-3/50020-5},
  editor    = {Alan Robinson and Andrei Voronkov},
  isbn      = {978-0-444-50813-3},
  location  = {Amsterdam},
  pages     = {1149-1238},
  publisher = {North-Holland},
  series    = {Handbook of Automated Reasoning},
  url       = {https://www.sciencedirect.com/science/article/pii/B9780444508133500205},
  file      = {:Barendregt2001 - Chapter 18 Proof Assistants Using Dependent Type Systems.pdf:PDF},
  priority  = {prio3},
}

@Book{Peano1889,
  author    = {Peano, Giuseppe},
  date      = {1889},
  title     = {Arithmetices principia: Nova methodo exposita},
  location  = {Torino},
  publisher = {Fratres Bocca},
  comment   = {Peano Axioms},
  groups    = {History},
  priority  = {prio3},
}

@Book{Whitehead1913,
  author    = {Alfred North Whitehead and Bertrand Russell},
  date      = {1913},
  title     = {Principia Mathematica},
  publisher = {Cambridge University Press},
  groups    = {History},
  priority  = {prio3},
}

@Book{GrattanGuinness2005,
  author    = {I. Grattan-Guinness and Roger Cooke and Leo Corry and Pierre Crépel and Niccolo Guicciardini},
  date      = {2005},
  title     = {Landmark Writings in Western Mathematics 1640-1940},
  doi       = {10.1016/B978-0-444-50871-3.X5080-3},
  publisher = {Elsevier Science},
  file      = {:GrattanGuinness2005 - Landmark Writings in Western Mathematics 1640 1940.pdf:PDF},
  groups    = {History},
  priority  = {prio3},
}

@Book{Dedekind1872,
  author    = {Richard Dedekind},
  date      = {1872},
  title     = {Stetigkeit und Undirrationale Zahlen},
  location  = {Braunschweig},
  publisher = {F. Vieweg und Sohn},
  comment   = {Dedekind cuts},
  groups    = {History},
  priority  = {prio3},
}

@Article{Cantor1872,
  author       = {Georg Cantor},
  date         = {1872},
  journaltitle = {Mathematische Annalen},
  title        = {Ueber die Ausdehnung eines Satzes aus der Theorie der trigonometrischen Reihen},
  pages        = {123-132},
  volume       = {5},
  comment      = {Construction of real numbers by Cauchy sequences},
  groups       = {History},
  priority     = {prio3},
}

@Book{Cantor1883,
  author    = {Georg Cantor},
  date      = {1883},
  title     = {Grundlagen einer allgemeinen Mannigfaltigkeitslehre. Ein mathematisch-philosophischer Versuch in der Lehre des Unendlichen},
  location  = {Leibnitz},
  publisher = {Teubner},
  comment   = {Foundation of set theory},
  groups    = {History},
  priority  = {prio3},
}

@Book{Frege1903,
  author    = {Gottlob Frege},
  date      = {1903},
  title     = {Grundgesetze der Arithmetik},
  location  = {Pohle},
  publisher = {Jena},
  volume    = {2},
  comment   = {Annex/Nachworte : basic law V is inconsistent (Russell paradox)},
  groups    = {History},
  priority  = {prio3},
}

@Article{Zermelo1908,
  author       = {Ernst Zermelo},
  date         = {1908},
  journaltitle = {Mathematische Annalen},
  title        = {Untersuchungen über die Grundlagen der Mengenlehre I},
  pages        = {261-281},
  volume       = {65},
  groups       = {History},
  priority     = {prio3},
}

@Article{Goedel1931,
  author       = {Kurt Gödel},
  date         = {1931},
  journaltitle = {Monatshefte für Mathematik und Physik},
  title        = {Über formal unentscheidbare Sätze der Principia mathematica und verwandter Systeme. I},
  pages        = {173-198},
  volume       = {37},
  comment      = {First and second incompleteness theorems},
  groups       = {History},
  priority     = {prio3},
}

@Book{Nederpelt1994,
  author    = {Rob Nederpelt and Herman Geuvers and Roel De Vrijer},
  date      = {1994},
  title     = {Selected papers on Automath},
  publisher = {Elsevier},
  file      = {:Nederpelt1994 - Selected Papers on Automath.pdf:PDF},
  groups    = {History},
  priority  = {prio3},
}

@InProceedings{DeBruijn1970,
  author       = {De Bruijn, Nicolaas Govert},
  booktitle    = {Symposium on automatic demonstration},
  date         = {1970},
  title        = {The mathematical language AUTOMATH, its usage, and some of its extensions},
  organization = {Springer},
  pages        = {29--61},
  groups       = {History, Proof Assistants},
  priority     = {prio3},
}

@InProceedings{Rudnicki1992,
  author    = {Rudnicki, Piotr},
  booktitle = {Proceedings of the 1992 Workshop on Types for Proofs and Programs},
  date      = {1992},
  title     = {An overview of the Mizar project},
  pages     = {311--330},
  file      = {:Rudnicki1992 - An Overview of the Mizar Project.pdf:PDF},
  groups    = {Proof Assistants, History},
  priority  = {prio3},
}

@Article{Voevodsky2010,
  author       = {Voevodsky, Vladimir},
  date         = {2010},
  journaltitle = {NSF grant application},
  title        = {Univalent foundations project},
  priority     = {prio3},
}

@Online{Scholze2021,
  author   = {Peter Scholze},
  date     = {2021},
  title    = {Half a year of the Liquid Tensor Experiment: Amazing developments},
  url      = {https://xenaproject.wordpress.com/2021/06/05/half-a-year-of-the-liquid-tensor-experiment-amazing-developments/},
  note     = {Blog post},
  urldate  = {2022-05-18},
  priority = {prio3},
}

@InProceedings{Delahaye2000,
  author    = {Delahaye, David},
  booktitle = {{Proceedings of Logic for Programming and Automated Reasoning (LPAR)}},
  date      = {2000-01},
  title     = {{A Tactic Language for the System Coq}},
  pages     = {85-95},
  series    = {LNCS/LNAI},
  volume    = {1955},
  file      = {:delahaye_hal-01125070 - A Tactic Language for the System Coq.pdf:PDF},
  groups    = {Proof Assistants},
  priority  = {prio3},
}

@InProceedings{Boehme2010,
  author       = {B{\"o}hme, Sascha and Nipkow, Tobias},
  booktitle    = {International Joint Conference on Automated Reasoning},
  date         = {2010},
  title        = {Sledgehammer: judgement day},
  organization = {Springer},
  pages        = {107--121},
  file         = {:Boehme2010 - Sledgehammer_ Judgement Day.pdf:PDF},
  groups       = {Proof Assistants},
  priority     = {prio3},
}

@InProceedings{Ekici2017,
  author    = {Ekici, Burak and Mebsout, Alain and Tinelli, Cesare and Keller, Chantal and Katz, Guy and Reynolds, Andrew and Barrett, Clark},
  booktitle = {{Computer Aided Verification - 29th International Conference}},
  date      = {2017-07},
  title     = {{SMTCoq: A plug-in for integrating SMT solvers into Coq}},
  location  = {Heidelberg, Germany},
  file      = {:Ekici2017 - SMTCoq_ a Plug in for Integrating SMT Solvers into Coq.pdf:PDF},
  groups    = {Proof Assistants},
  priority  = {prio3},
}

@InProceedings{Aydemir2005,
  author       = {Aydemir, Brian and Bohannon, Aaron and Fairbairn, Matthew and Foster, Nathan and Pierce, Benjamin and Sewell, Peter and Vytiniotis, Dimitrios and Washburn, Geoffrey and Weirich, Stephanie and Zdancewic, Steve},
  booktitle    = {International Conference on Theorem Proving in Higher Order Logics},
  date         = {2005},
  title        = {Mechanized metatheory for the masses: the POPLmark challenge},
  organization = {Springer},
  pages        = {50--65},
  priority     = {prio3},
}

@Unpublished{McBride2022,
  author   = {Conor McBride},
  date     = {2022},
  title    = {Types Who Say Ni},
  priority = {prio1},
}

@PhdThesis{Girard1972,
  author      = {Girard, Jean-Yves},
  date        = {1972},
  institution = {Université Paris VII},
  title       = {Interpr{\'e}tation fonctionnelle et {\'e}limination des coupures de l'arithm{\'e}tique d'ordre sup{\'e}rieur},
  file        = {:Girard1972 - Interpretation Fonctionnelle Et Elimination Des Coupures De L'arithmetique D'ordre Superieur.pdf:PDF},
  priority    = {prio3},
}

@Misc{MartinLoef1972,
  author        = {Per Martin-L{\"o}f},
  date          = {1972},
  title         = {An intuitionistic theory of types},
  priority      = {prio3},
  related       = {Sambin1998},
  relatedstring = {Reprinted in},
}

@Book{Sambin1998,
  author    = {Sambin, Giovanni and Smith, Jan},
  date      = {1998},
  title     = {Twenty five years of constructive type theory},
  publisher = {Clarendon Press},
  volume    = {36},
  priority  = {prio3},
}

@InProceedings{Assaf2015,
  author     = {Ali Assaf},
  booktitle  = {20th International Conference on Types for Proofs and Programs (TYPES 2014)},
  date       = {2015},
  title      = {{A Calculus of Constructions with Explicit Subtyping}},
  doi        = {10.4230/LIPIcs.TYPES.2014.27},
  editor     = {Hugo Herbelin and Pierre Letouzey and Matthieu Sozeau},
  isbn       = {978-3-939897-88-0},
  location   = {Dagstuhl, Germany},
  pages      = {27--46},
  publisher  = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  series     = {Leibniz International Proceedings in Informatics (LIPIcs)},
  url        = {http://drops.dagstuhl.de/opus/volltexte/2015/5490},
  volume     = {39},
  annotation = {Keywords: type theory, calculus of constructions, universes, cumulativity, subtyping},
  file       = {:Assaf2015 - A Calculus of Constructions with Explicit Subtyping.pdf:PDF},
  issn       = {1868-8969},
  priority   = {prio1},
  urn        = {urn:nbn:de:0030-drops-54904},
}

@InProceedings{Luo1989,
  author    = {Luo, Z.},
  booktitle = {Fourth Annual Symposium on Logic in Computer Science},
  date      = {1989},
  title     = {ECC, an extended calculus of constructions},
  doi       = {10.1109/LICS.1989.39193},
  pages     = {386-395},
  file      = {:Luo1989 - ECC, an Extended Calculus of Constructions.pdf:PDF},
  priority  = {prio3},
}

@Article{Hindley1969,
  author       = {R. Hindley},
  date         = {1969},
  journaltitle = {Transactions of the American Mathematical Society},
  title        = {The Principal Type-Scheme of an Object in Combinatory Logic},
  issn         = {0002-9947},
  pages        = {29--60},
  url          = {http://www.jstor.org/stable/1995158},
  volume       = {146},
  file         = {:Hindley1969 - The Principal Type Scheme of an Object in Combinatory Logic.pdf:PDF},
  priority     = {prio3},
  publisher    = {American Mathematical Society},
}

@TechReport{Timany2017,
  author      = {Timany, Amin and Sozeau, Matthieu},
  date        = {2017-10},
  institution = {{KU Leuven, Belgium ; Inria Paris}},
  title       = {{Consistency of the Predicative Calculus of Cumulative Inductive Constructions (pCuIC)}},
  number      = {RR-9105},
  pages       = {32},
  type        = {Research Report},
  url         = {https://hal.inria.fr/hal-01615123},
  file        = {:Timany2017 - Consistency of the Predicative Calculus of Cumulative Inductive Constructions (pCuIC).pdf:PDF},
  hal_id      = {hal-01615123},
  hal_version = {v3},
  keywords    = {logic ; metatheory ; calculus of constructions ; set theory ; calcul des constructions ; Coq ; m{\'e}tath{\'e}orie ; th{\'e}orie des ensembles ; logique},
  priority    = {prio3},
}

@Article{LennonBertrand2022,
  author       = {Lennon-Bertrand, Meven and Maillard, Kenji and Tabareau, Nicolas and Tanter, {\'E}ric},
  date         = {2022},
  journaltitle = {{ACM Transactions on Programming Languages and Systems (TOPLAS)}},
  title        = {{Gradualizing the Calculus of Inductive Constructions}},
  doi          = {10.1145/3495528},
  note         = {To appear},
  url          = {https://hal.archives-ouvertes.fr/hal-02896776},
  file         = {:LennonBertrand2022 - Gradualizing the Calculus of Inductive Constructions.pdf:PDF},
  hal_id       = {hal-02896776},
  hal_version  = {v5},
  priority     = {prio3},
  publisher    = {{ACM}},
}

@Thesis{Gimenez1996,
  author      = {Eduardo Giménez},
  date        = {1996},
  institution = {École Normale Supérieure de Lyon},
  title       = {Un Calcul des Constructions Infinies et son Application à la Vérification de Systèmes Communicants},
  type        = {phdthesis},
  file        = {:Gimenez1996 - Un Calcul Des Constructions Infinies Et Son Application À La Vérification De Systèmes Communicants.pdf:PDF},
  priority    = {prio3},
}

@InProceedings{Abel2013,
  author    = {Andreas Abel and Brigitte Pientka and David Thibodeau and Anton Setzer},
  booktitle = {The 40th Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages, {POPL} '13, Rome, Italy - January 23 - 25, 2013},
  date      = {2013},
  title     = {Copatterns: programming infinite structures by observations},
  doi       = {10.1145/2429069.2429075},
  editor    = {Roberto Giacobazzi and Radhia Cousot},
  pages     = {27--38},
  publisher = {{ACM}},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl    = {https://dblp.org/rec/conf/popl/AbelPTS13.bib},
  file      = {:Abel2013 - Copatterns_ Programming Infinite Structures by Observations.pdf:PDF},
  priority  = {prio2},
  timestamp = {Thu, 24 Jun 2021 16:19:31 +0200},
}

@InProceedings{Cohen2020,
  author      = {Cohen, Cyril and Sakaguchi, Kazuhiko and Tassi, Enrico},
  booktitle   = {{FSCD 2020 - 5th International Conference on Formal Structures for Computation and Deduction}},
  date        = {2020-06},
  title       = {{Hierarchy Builder: algebraic hierarchies made easy in Coq with Elpi}},
  doi         = {10.4230/LIPIcs.FSCD.2020.34},
  location    = {Paris, France},
  number      = {167},
  pages       = {34:1--34:21},
  series      = {5th International Conference on Formal Structures for Computation and Deduction (FSCD 2020)},
  url         = {https://hal.inria.fr/hal-02478907},
  file        = {:Cohen2020 - Hierarchy Builder_ Algebraic Hierarchies Made Easy in Coq with Elpi.pdf:PDF},
  hal_id      = {hal-02478907},
  hal_version = {v5},
  keywords    = {$\lambda$Prolog ; Elpi ; Metaprogramming ; Packed Classes ; Coq ; Algebraic Hierarchy},
  priority    = {prio3},
}

@Eprint{Haselwarter2021,
  author    = {Haselwarter, Philipp G. and Bauer, Andrej},
  copyright = {arXiv.org perpetual, non-exclusive license},
  doi       = {10.48550/ARXIV.2112.00539},
  file      = {:Haselwarter2021 - Finitary Type Theories with and without Contexts.pdf:PDF},
  keywords  = {Logic (math.LO), Logic in Computer Science (cs.LO), FOS: Mathematics, FOS: Computer and information sciences, 03B38, 03F50, 68V15, 03F07},
  priority  = {prio3},
  publisher = {arXiv},
  title     = {Finitary type theories with and without contexts},
  url       = {https://arxiv.org/abs/2112.00539},
  year      = {2021},
}

@Article{Tait1967,
  author       = {Tait, William W},
  date         = {1967},
  journaltitle = {The journal of symbolic logic},
  title        = {Intensional interpretations of functionals of finite type I},
  number       = {2},
  pages        = {198--212},
  volume       = {32},
  comment      = {Reducibility},
  priority     = {prio3},
  publisher    = {Cambridge University Press},
}

@Thesis{Abel2013a,
  author      = {Andreas Abel},
  date        = {2013},
  institution = {Institut für Informatik, Ludwig-Maximilians-Universität München},
  title       = {Normalization by Evaluation: Dependent Types and Impredicativity},
  type        = {Habilitation thesis},
  file        = {:Abel2013a - Normalization by Evaluation_ Dependent Types and Impredicativity.pdf:PDF},
  priority    = {prio2},
}

@Article{Wright1994,
  author       = {Andrew Wright and Matthias Felleisen},
  date         = {1994},
  journaltitle = {Information and Computation},
  title        = {A Syntactic Approach to Type Soundness},
  doi          = {10.1006/inco.1994.1093},
  issn         = {0890-5401},
  number       = {1},
  pages        = {38-94},
  url          = {https://www.sciencedirect.com/science/article/pii/S0890540184710935},
  volume       = {115},
  abstract     = {We present a new approach to proving type soundness for Hindley/Milner-style polymorphic type systems. The keys to our approach are (1) an adaptation of subject reduction theorems from combinatory logic to programming languages, and (2) the use of rewriting techniques for the specification of the language semantics. The approach easily extends from polymorphic functional languages to imperative languages that provide references, exceptions, continuations, and similar features. We illustrate the technique with a type soundness theorem for the core of Standard ML, which includes the first type soundness proof for polymorphic exceptions and continuations.},
  priority     = {prio3},
}

@Unpublished{Sozeau2022,
  author       = {Matthieu Sozeau and Meven Lennon-Bertrand and Yannick Forster},
  date         = {2022},
  title        = {{The Curious Case of Case: Correct \& Efficient Representation of Case Analysis in Coq and MetaCoq}},
  howpublished = {Talk},
  location     = {1st Workshop on the Implementation of Type Systems},
  priority     = {prio3},
}

@Article{Lewis2022,
  author       = {Lewis, Robert Y. and Wu, Minchao},
  date         = {2022},
  journaltitle = {Journal of Automated Reasoning},
  title        = {A Bi-Directional Extensible Interface Between Lean and Mathematica},
  doi          = {10.1007/s10817-021-09611-1},
  issn         = {1573-0670},
  url          = {https://doi.org/10.1007/s10817-021-09611-1},
  abstract     = {We implement a user-extensible ad hoc connection between the Lean proof assistant and the computer algebra system Mathematica. By reflecting the syntax of each system in the other and providing a flexible interface for extending translation, our connection allows for the exchange of arbitrary information between the two systems. We show how to make use of the Lean metaprogramming framework to verify certain Mathematica computations, so that the rigor of the proof assistant is not compromised. We also use Mathematica as an untrusted oracle to guide proof search in the proof assistant and interact with a Mathematica notebook from within a Lean session. In the other direction, we import and process Lean declarations from within Mathematica. The proof assistant library serves as a database of mathematical knowledge that the CAS can display and explore.},
  priority     = {prio3},
  refid        = {Lewis2022},
}

@Article{Melquiond2012,
  author       = {Guillaume Melquiond},
  date         = {2012},
  journaltitle = {Information and Computation},
  title        = {Floating-point arithmetic in the Coq system},
  doi          = {10.1016/j.ic.2011.09.005},
  issn         = {0890-5401},
  note         = {Special Issue: 8th Conference on Real Numbers and Computers},
  pages        = {14-23},
  url          = {https://www.sciencedirect.com/science/article/pii/S0890540112000739},
  volume       = {216},
  abstract     = {The process of proving some mathematical theorems can be greatly reduced by relying on numerically-intensive computations with a certified arithmetic. This article presents a formalization of floating-point arithmetic that makes it possible to efficiently compute inside the proofs of the Coq system. This certified library is a multi-radix and multi-precision implementation free from underflow and overflow. It provides the basic arithmetic operators and a few elementary functions.},
  keywords     = {Floating-point arithmetic, Formal proofs, Coq system},
  priority     = {prio3},
}

@Eprint{Maillard2022,
  author      = {Maillard, Kenji and Lennon-Bertrand, Meven and Tabareau, Nicolas and Tanter, {\'E}ric},
  date        = {2022-03},
  eprint      = {hal-03596652},
  eprinttype  = {Hal},
  file        = {main.pdf:https\:/hal.inria.fr/hal-03596652/file/main.pdf:PDF},
  hal_id      = {hal-03596652},
  hal_version = {v1},
  priority    = {prio3},
  title       = {{A Reasonably Gradual Type Theory}},
  url         = {https://hal.inria.fr/hal-03596652},
}

@Article{Knowles2010,
  author       = {Kenneth Knowles and Cormac Flanagan},
  journaltitle = {ACM Transactions on Programming Languages and Systems},
  title        = {Hybrid type checking},
  number       = {2},
  volume       = {32},
  month        = jan,
  priority     = {prio3},
  publisher    = {ACM Press},
  year         = {2010},
}

@InProceedings{Ou2004,
  author    = {Xinming Ou and Gang Tan and Yitzhak Mandelbaum and David Walker},
  booktitle = {Proceedings of the IFIP International Conference on Theoretical Computer Science},
  date      = {2004},
  title     = {Dynamic Typing with Dependent Types},
  pages     = {437--450},
  priority  = {prio3},
}

@Article{BanadosSchwerter2016,
  author       = {Bañados Schwerter, Felipe and Garcia, Ronald and Tanter, Éric},
  date         = {2016},
  journaltitle = {Journal of Functional Programming},
  title        = {Gradual type-and-effect systems},
  doi          = {10.1017/S0956796816000162},
  volume       = {26},
  priority     = {prio3},
  publisher    = {Cambridge University Press},
}

@InProceedings{Fennell2013,
  author    = {Fennell, Luminous and Thiemann, Peter},
  booktitle = {2013 IEEE 26th Computer Security Foundations Symposium},
  date      = {2013},
  title     = {Gradual Security Typing with References},
  doi       = {10.1109/CSF.2013.22},
  pages     = {224-239},
  priority  = {prio3},
}

@Article{Toro2018,
  author       = {Toro, Mat\'{\i}as and Garcia, Ronald and Tanter, \'{E}ric},
  date         = {2018-12},
  journaltitle = {ACM Trans. Program. Lang. Syst.},
  title        = {Type-Driven Gradual Security with References},
  doi          = {10.1145/3229061},
  issn         = {0164-0925},
  number       = {4},
  volume       = {40},
  abstract     = {In security-typed programming languages, types statically enforce noninterference between potentially conspiring values, such as the arguments and results of functions. But to adopt static security types, like other advanced type disciplines, programmers face a steep wholesale transition, often forcing them to refactor working code just to satisfy their type checker. To provide a gentler path to security typing that supports safe and stylish but hard-to-verify programming idioms, researchers have designed languages that blend static and dynamic checking of security types. Unfortunately, most of the resulting languages only support static, type-based reasoning about noninterference if a program is entirely statically secured. This limitation substantially weakens the benefits that dynamic enforcement brings to static security typing. Additionally, current proposals are focused on languages with explicit casts and therefore do not fulfill the vision of gradual typing, according to which the boundaries between static and dynamic checking only arise from the (im)precision of type annotations and are transparently mediated by implicit checks.In this article, we present GSLRef, a gradual security-typed higher-order language with references. As a gradual language, GSLRef supports the range of static-to-dynamic security checking exclusively driven by type annotations, without resorting to explicit casts. Additionally, GSLRef lets programmers use types to reason statically about termination-insensitive noninterference in all programs, even those that enforce security dynamically. We prove that GSLRef satisfies all but one of Siek et al.’s criteria for gradually-typed languages, which ensure that programs can seamlessly transition between simple typing and security typing. A notable exception regards the dynamic gradual guarantee, which some specific programs must violate if they are to satisfy noninterference; it remains an open question whether such a language could fully satisfy the dynamic gradual guarantee. To realize this design, we were led to draw a sharp distinction between syntactic type safety and semantic type soundness, each of which constrains the design of the gradual language.},
  articleno    = {16},
  issue_date   = {December 2018},
  keywords     = {gradual typing, language-based security, Noninterference},
  location     = {New York, NY, USA},
  numpages     = {55},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@InProceedings{Thiemann2014,
  author    = {Thiemann, Peter and Fennell, Luminous},
  booktitle = {Programming Languages and Systems},
  date      = {2014},
  title     = {Gradual Typing for Annotated Type Systems},
  editor    = {Shao, Zhong},
  isbn      = {978-3-642-54833-8},
  location  = {Berlin, Heidelberg},
  pages     = {47--66},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Annotated type systems include additional information in types to make them more expressive and to gather intensional information about programs. Gradual types enable a seamless transition between statically and dynamically checked properties of values. Gradual annotation typing applies the ideas of gradual typing to the annotation part of a type system.},
  priority  = {prio3},
}

@InProceedings{Bierman2010,
  author    = {Bierman, Gavin and Meijer, Erik and Torgersen, Mads},
  booktitle = {ECOOP 2010 -- Object-Oriented Programming},
  date      = {2010},
  title     = {Adding Dynamic Types to C\#},
  editor    = {D'Hondt, Theo},
  isbn      = {978-3-642-14107-2},
  location  = {Berlin, Heidelberg},
  pages     = {76--100},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Developers using statically typed languages such as C{\$}^{\backslash}sharp{\$}and Java are increasingly having to interoperate with APIs and object models defined in dynamic languages. This impedance mismatch results in code that is difficult to understand, awkward to analyze, and expensive to maintain. In this paper we describe new features in C{\$}^{\backslash}sharp{\$}4.0 that support the safe combination of dynamically and statically typed code by deferring type checking of program fragments with static type dynamic until runtime. When executed, these dynamic code fragments are type-checked and resolved using the same rules as statically typed code. We formalize these features in a core fragment of C{\$}^{\backslash}sharp{\$}and prove important safety properties. In particular, we show that subtyping remains transitive.},
  priority  = {prio3},
}

@Article{Herman2010,
  author    = {Herman, David and Tomb, Aaron and Flanagan, Cormac},
  title     = {Space-efficient gradual typing},
  number    = {2},
  pages     = {167--189},
  volume    = {23},
  journal   = {Higher-Order and Symbolic Computation},
  priority  = {prio3},
  publisher = {Springer},
  year      = {2010},
}

@InProceedings{TobinHochstadt2008,
  author    = {Tobin-Hochstadt, Sam and Felleisen, Matthias},
  booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  date      = {2008},
  title     = {The Design and Implementation of Typed Scheme},
  doi       = {10.1145/1328438.1328486},
  isbn      = {9781595936899},
  location  = {San Francisco, California, USA},
  pages     = {395–406},
  publisher = {Association for Computing Machinery},
  series    = {POPL '08},
  abstract  = {When scripts in untyped languages grow into large programs, maintaining them becomes difficult. A lack of types in typical scripting languages means that programmers must (re)discover critical pieces of design information every time they wish to change a program. This analysis step both slows down the maintenance process and may even introduce mistakes due to the violation of undiscovered invariants.This paper presents Typed Scheme, an explicitly typed extension of an untyped scripting language. Its type system is based on the novel notion of occurrence typing, which we formalize and mechanically prove sound. The implementation of Typed Scheme additionally borrows elements from a range of approaches, including recursive types, true unions and subtyping, plus polymorphism combined with a modicum of local inference. Initial experiments with the implementation suggest that Typed Scheme naturally accommodates the programming style of the underlying scripting language, at least for the first few thousand lines of ported code.},
  address   = {New York, NY, USA},
  keywords  = {type systems, scheme},
  numpages  = {12},
  priority  = {prio3},
}

@InProceedings{Siek2010,
  author    = {Siek, Jeremy G. and Wadler, Philip},
  booktitle = {Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  date      = {2010},
  title     = {Threesomes, with and without Blame},
  doi       = {10.1145/1706299.1706342},
  isbn      = {9781605584799},
  location  = {Madrid, Spain},
  pages     = {365–376},
  publisher = {Association for Computing Machinery},
  series    = {POPL '10},
  abstract  = {How to integrate static and dynamic types? Recent work focuses on casts to mediate between the two. However, adding casts may degrade tail calls into a non-tail calls, increasing space consumption from constant to linear in the depth of calls.We present a new solution to this old problem, based on the notion of a threesome. A cast is specified by a source and a target type--a twosome. Any twosome factors into a downcast from the source to an intermediate type, followed by an upcast from the intermediate to the target---a threesome. Any chain of threesomes collapses to a single threesome, calculated by taking the greatest lower bound of the intermediate types. We augment this solution with blame labels to map any failure of a threesome back to the offending twosome in the source program.Herman, Tomb, and Flanagan (2007) solve the space problem by representing casts with the coercion calculus of Henglein (1994). While they provide a theoretical limit on the space overhead, there remains the practical question of how best to implement coercion reduction. The threesomes presented in this paper provide a streamlined data structure and algorithm for representing and normalizing coercions. Furthermore, threesomes provide a typed-based explanation of coercion reduction.},
  address   = {New York, NY, USA},
  keywords  = {casts, lambda-calculus, blame tracking, coercions},
  numpages  = {12},
  priority  = {prio3},
}

@InProceedings{Siek2009,
  author    = {Siek, Jeremy and Garcia, Ronald and Taha, Walid},
  booktitle = {Programming Languages and Systems},
  date      = {2009},
  title     = {Exploring the Design Space of Higher-Order Casts},
  editor    = {Castagna, Giuseppe},
  isbn      = {978-3-642-00590-9},
  location  = {Berlin, Heidelberg},
  pages     = {17--31},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {This paper explores the surprisingly rich design space for the simply typed lambda calculus with casts and a dynamic type. Such a calculus is the target intermediate language of the gradually typed lambda calculus but it is also interesting in its own right. In light of diverse requirements for casts, we develop a modular semantic framework, based on Henglein's Coercion Calculus, that instantiates a number of space-efficient, blame-tracking calculi, varying in what errors they detect and how they assign blame. Several of the resulting calculi extend work from the literature with either blame tracking or space efficiency, and in doing so reveal previously unknown connections. Furthermore, we introduce a new strategy for assigning blame under which casts that respect traditional subtyping are statically guaranteed to never fail. One particularly appealing outcome of this work is a novel cast calculus that is well-suited to gradual typing.},
  priority  = {prio3},
}

@Article{Toro2020,
  author       = {Matías Toro and Éric Tanter},
  date         = {2020},
  journaltitle = {Science of Computer Programming},
  title        = {Abstracting gradual references},
  doi          = {10.1016/j.scico.2020.102496},
  issn         = {0167-6423},
  pages        = {102496},
  url          = {https://www.sciencedirect.com/science/article/pii/S0167642320301052},
  volume       = {197},
  abstract     = {Gradual typing is an effective approach to integrate static and dynamic typing, which supports the smooth transition between both extremes via the imprecision of type annotations. Gradual typing has been applied in many scenarios such as objects, subtyping, effects, ownership, typestates, information-flow typing, parametric polymorphism, etc. In particular, the combination of gradual typing and mutable references has been explored by different authors, giving rise to four different semantics—invariant, guarded, monotonic and permissive references. These semantics were specially crafted to reflect different design decisions with respect to precision and efficiency tradeoffs. Since then, progress has been made in the formulation of methodologies to systematically derive gradual counterparts of statically-typed languages, but these have not been applied to study mutable references. In this article, we explore how the Abstracting Gradual Typing (AGT) methodology, which has been shown to be effective in a variety of settings, applies to mutable references. Starting from a standard statically-typed language with references, we systematically derive with AGT a novel gradual language, called λREF˜. We establish the properties of λREF˜; in particular, it is the first gradual language with mutable references that is proven to satisfy the gradual guarantee. We then compare λREF˜ with the main four existing approaches to gradual references, and show that the application of AGT does justify one of the proposed semantics: we formally prove that the treatment of references in λREF˜ corresponds to the guarded semantics, by presenting a bisimilation with the coercion semantics of Herman et al. In the process, we uncover that any direct application of AGT yields a gradual language that is not space-efficient. We consequently adjust the dynamic semantics of λREF˜ to recover space efficiency. We then show how to extend λREF˜ to support both monotonic and permissive references as well. Finally, we provide the first proof of the dynamic gradual guarantee for monotonic references. As a result, this paper sheds further light on the design space of gradual languages with mutable references and contributes to deepening the understanding of the AGT methodology.},
  keywords     = {Gradual typing, Mutable references, Abstract interpretation},
  priority     = {prio3},
}

@Article{BanadosSchwerter2021,
  author       = {Bañados Schwerter, Felipe and Clark, Alison M. and Jafery, Khurram A. and Garcia, Ronald},
  date         = {2021-01},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {Abstracting Gradual Typing Moving Forward: Precise and Space-Efficient},
  doi          = {10.1145/3434342},
  number       = {POPL},
  volume       = {5},
  abstract     = {Abstracting Gradual Typing (AGT) is a systematic approach to designing gradually-typed languages. Languages developed using AGT automatically satisfy the formal semantic criteria for gradual languages identified by Siek et al. Nonetheless, vanilla AGT semantics can still have important shortcomings. First, a gradual language's runtime checks should preserve the space-efficiency guarantees inherent to the underlying static and dynamic languages. To the contrary, the default operational semantics of AGT break proper tail calls. Second, a gradual language's runtime checks should enforce basic modular type-based invariants expected from the static type discipline. To the contrary, the default operational semantics of AGT may fail to enforce some invariants in surprising ways. We demonstrate this in the GTFL≲ language of Garcia et al.  This paper addresses both problems at once by refining the theory underlying AGT's dynamic checks. Garcia et al. observe that AGT involves two abstractions of static types: one for the static semantics and one for the dynamic semantics. We recast the latter as an abstract interpretation of subtyping itself, while gradual types still abstract static types. Then we show how forward-completeness (Giacobazzi and Quintarelli) is key to supporting both space-efficient execution and reliable runtime type enforcement.},
  articleno    = {61},
  issue_date   = {January 2021},
  keywords     = {gradual typing, subtyping, cast calculi, abstract interpretation},
  location     = {New York, NY, USA},
  numpages     = {28},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@Article{New2018,
  author       = {New, Max S. and Ahmed, Amal},
  date         = {2018-07},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {Graduality from Embedding-Projection Pairs},
  doi          = {10.1145/3236768},
  number       = {ICFP},
  volume       = {2},
  abstract     = {Gradually typed languages allow statically typed and dynamically typed code to interact while maintaining benefits of both styles. The key to reasoning about these mixed programs is Siek-Vitousek-Cimini-Boyland’s (dynamic) gradual guarantee, which says that giving components of a program more precise types only adds runtime type checking, and does not otherwise change behavior. In this paper, we give a semantic reformulation of the gradual guarantee called graduality. We change the name to promote the analogy that graduality is to gradual typing what parametricity is to polymorphism. Each gives a local-to-global, syntactic-to-semantic reasoning principle that is formulated in terms of a kind of observational approximation. Utilizing the analogy, we develop a novel logical relation for proving graduality. We show that embedding-projection pairs (ep pairs) are to graduality what relations are to parametricity. We argue that casts between two types where one is “more dynamic” (less precise) than the other necessarily form an ep pair, and we use this to cleanly prove the graduality cases for casts from the ep-pair property. To construct ep pairs, we give an analysis of the type dynamism relation—also known as type precision or na\"{\i}ve subtyping—that interprets the rules for type dynamism as compositional constructions on ep pairs, analogous to the coercion interpretation of subtyping.},
  articleno    = {73},
  issue_date   = {September 2018},
  keywords     = {dynamic gradual guarantee, logical relations, gradual typing, observational error approximation},
  location     = {New York, NY, USA},
  numpages     = {30},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@Article{Igarashi2017,
  author       = {Igarashi, Yuu and Sekiyama, Taro and Igarashi, Atsushi},
  date         = {2017-08},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  title        = {On Polymorphic Gradual Typing},
  doi          = {10.1145/3110284},
  number       = {ICFP},
  volume       = {1},
  abstract     = {We study an extension of gradual typing—a method to integrate dynamic typing and static typing smoothly in a single language—to parametric polymorphism and its theoretical properties, including conservativity of typing and semantics over both statically and dynamically typed languages, type safety, blame-subtyping theorem, and the gradual guarantee—the so-called refined criteria, advocated by Siek et al. We develop System FG, which is a gradually typed extension of System F with the dynamic type and a new type consistency relation, and translation to a new polymorphic blame calculus System FC, which is based on previous polymorphic blame calculi by Ahmed et al. The design of System FG and System FC, geared to the criteria, is influenced by the distinction between static and gradual type variables, first observed by Garcia and Cimini. This distinction is also useful to execute statically typed code without incurring additional overhead to manage type names as in the prior calculi. We prove that System FG satisfies most of the criteria: all but the hardest property of the gradual guarantee on semantics. We show that a key conjecture to prove the gradual guarantee leads to the Jack-of-All-Trades property, conjectured as an important property of the polymorphic blame calculus by Ahmed et al.},
  articleno    = {40},
  issue_date   = {September 2017},
  keywords     = {gradual guarantee, parametric polymorphism, gradual typing},
  location     = {New York, NY, USA},
  numpages     = {29},
  priority     = {prio3},
  publisher    = {Association for Computing Machinery},
}

@Eprint{Eisenberg2016,
  author     = {Eisenberg, Richard},
  date       = {2016},
  eprint     = {1610.07978},
  eprinttype = {arXiv},
  priority   = {prio3},
  title      = {Dependent Types in Haskell: Theory and Practice},
}

@Article{Brady2013,
  author       = {Brady, Edwin},
  date         = {2013},
  journaltitle = {Journal of Functional Programming},
  title        = {Idris, a general-purpose dependently typed programming language: Design and implementation},
  number       = {5},
  pages        = {552--593},
  volume       = {23},
  priority     = {prio3},
  publisher    = {Cambridge University Press},
}

@InProceedings{Garcia2020,
  author    = {Garcia, Ronald and Tanter, {\'E}ric},
  booktitle = {Informal Proceedings of the ACM SIGPLAN Workshop on Gradual Typing (WGT20)},
  date      = {2020},
  title     = {Gradual Typing as if Types Mattered},
  priority  = {prio3},
}

@InProceedings{Nguyen2019,
  author    = {Nguyễn, Ph{\'u}c and Gilray, Thomas and Tobin-Hochstadt, Sam and Van Horn, David},
  booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  title     = {Size-Change Termination as a Contract: Dynamically and Statically Enforcing Termination for Higher-Order Programs},
  doi       = {10.1145/3314221.3314643},
  isbn      = {9781450367127},
  location  = {Phoenix, AZ, USA},
  pages     = {845–859},
  publisher = {Association for Computing Machinery},
  series    = {PLDI 2019},
  url       = {https://doi.org/10.1145/3314221.3314643},
  abstract  = {Termination is an important but undecidable program property, which has led to a large body of work on static methods for conservatively predicting or enforcing termination. One such method is the size-change termination approach of Lee, Jones, and Ben-Amram, which operates in two phases: (1) abstract programs into “size-change graphs,” and (2) check these graphs for the size-change property: the existence of paths that lead to infinite decreasing sequences. We transpose these two phases with an operational semantics that accounts for the run-time enforcement of the size-change property, postponing (or entirely avoiding) program abstraction. This choice has two key consequences: (1) size-change termination can be checked at run-time and (2) termination can be rephrased as a safety property analyzed using existing methods for systematic abstraction. We formulate run-time size-change checks as contracts in the style of Findler and Felleisen. The result compliments existing contracts that enforce partial correctness specifications to obtain contracts for total correctness. Our approach combines the robustness of the size-change principle for termination with the precise information available at run-time. It has tunable overhead and can check for nontermination without the conservativeness necessary in static checking. To obtain a sound and computable termination analysis, we apply existing abstract interpretation techniques directly to the operational semantics, avoiding the need for custom abstractions for termination. The resulting analyzer is competitive with with existing, purpose-built analyzers.},
  address   = {New York, NY, USA},
  keywords  = {termination, verification, size-change principle},
  numpages  = {15},
  priority  = {prio3},
  year      = {2019},
}

@Online{CoqManual,
  author   = {{Coq Development Team}, The},
  date     = {2022-01},
  title    = {The Coq proof assistant reference manual},
  url      = {https://coq.inria.fr/refman/},
  note     = {Version 8.15},
  urldate  = {2022-04-11},
  priority = {prio3},
}

@InProceedings{Siek2007,
  author    = {Siek, Jeremy and Taha, Walid},
  booktitle = {ECOOP 2007 -- Object-Oriented Programming},
  date      = {2007},
  title     = {Gradual Typing for Objects},
  editor    = {Ernst, Erik},
  isbn      = {978-3-540-73589-2},
  location  = {Berlin, Heidelberg},
  pages     = {2--27},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Static and dynamic type systems have well-known strengths and weaknesses. In previous work we developed a gradual type system for a functional calculus named {\$}{\backslash}lambda^?{\_}{\backslash}to{\$}. Gradual typing provides the benefits of both static and dynamic checking in a single language by allowing the programmer to control whether a portion of the program is type checked at compile-time or run-time by adding or removing type annotations on variables. Several object-oriented scripting languages are preparing to add static checking. To support that work this paper develops {\$}{\backslash}mathbf{\{}Ob{\}}^{\{}?{\}}{\_}{\{}<:{\}}{\$}, a gradual type system for object-based languages, extending the Ob<{\thinspace}: calculus of Abadi and Cardelli. Our primary contribution is to show that gradual typing and subtyping are orthogonal and can be combined in a principled fashion. We also develop a small-step semantics, provide a machine-checked proof of type safety, and improve the space efficiency of higher-order casts.},
  priority  = {prio3},
}

@Book{Levy2004,
  author    = {Paul Blain Levy},
  date      = {2004},
  title     = {Call-By-Push-Value: {A} Functional/Imperative Synthesis},
  isbn      = {1-4020-1730-8},
  publisher = {Springer},
  series    = {Semantics Structures in Computation},
  volume    = {2},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl    = {https://dblp.org/rec/books/sp/Levy2004.bib},
  priority  = {prio3},
  timestamp = {Tue, 12 Sep 2006 09:32:36 +0200},
}

@InProceedings{Findler2002,
  author    = {Findler, Robert Bruce and Felleisen, Matthias},
  booktitle = {Proceedings of the Seventh ACM SIGPLAN International Conference on Functional Programming},
  date      = {2002},
  title     = {Contracts for Higher-Order Functions},
  doi       = {10.1145/581478.581484},
  isbn      = {1581134878},
  location  = {Pittsburgh, PA, USA},
  pages     = {48–59},
  publisher = {Association for Computing Machinery},
  series    = {ICFP '02},
  abstract  = {Assertions play an important role in the construction of robust software. Their use in programming languages dates back to the 1970s. Eiffel, an object-oriented programming language, wholeheartedly adopted assertions and developed the "Design by Contract" philosophy. Indeed, the entire object-oriented community recognizes the value of assertion-based contracts on methods.In contrast, languages with higher-order functions do not support assertion-based contracts. Because predicates on functions are, in general, undecidable, specifying such predicates appears to be meaningless. Instead, the functional languages community developed type systems that statically approximate interesting predicates.In this paper, we show how to support higher-order function contracts in a theoretically well-founded and practically viable manner. Specifically, we introduce λcon, a typed lambda calculus with assertions for higher-order functions. The calculus models the assertion monitoring system that we employ in DrScheme. We establish basic properties of the model (type soundness, etc.) and illustrate the usefulness of contract checking with examples from DrScheme's code base.We believe that the development of an assertion system for higher-order functions serves two purposes. On one hand, the system has strong practical potential because existing type systems simply cannot express many assertions that programmers would like to state. On the other hand, an inspection of a large base of invariants may provide inspiration for the direction of practical future type system research.},
  address   = {New York, NY, USA},
  keywords  = {solfware reliability, predicate typing, behavioral specifications, contracts, higher-order functions},
  numpages  = {12},
  priority  = {prio3},
}

@Article{Zermelo1904,
  author       = {Zermelo, E.},
  date         = {1904},
  journaltitle = {Mathematische Annalen},
  title        = {Beweis, daß jede Menge wohlgeordnet werden kann},
  doi          = {10.1007/BF01445300},
  issn         = {1432-1807},
  number       = {4},
  pages        = {514--516},
  url          = {https://doi.org/10.1007/BF01445300},
  volume       = {59},
  priority     = {prio3},
  refid        = {Zermelo1904},
}

@Article{MartinLoef1996,
  author       = {Per Martin{-}L\"of},
  date         = {1996},
  journaltitle = {Nordic Journal of Philosophical Logic},
  title        = {On the Meanings of the Logical Constants and the Justifications of the Logical Laws},
  number       = {1},
  pages        = {11--60},
  volume       = {1},
  priority     = {prio3},
  publisher    = {Scandinavian University Press},
}

@Article{Ghani2015,
  author       = {Neil Ghani and Lorenzo Malatesta and Fredrik Nordvall Forsberg},
  date         = {2015},
  journaltitle = {Logical Methods in Computer Science},
  title        = {Positive Inductive-Recursive Definitions},
  doi          = {10.2168/LMCS-11(1:13)2015},
  number       = {1},
  volume       = {11},
  priority     = {prio3},
}

@Article{Dybjer2003,
  author       = {Peter Dybjer and Anton Setzer},
  date         = {2003},
  journaltitle = {Annals of Pure and Applied Logic},
  title        = {Induction-recursion and initial algebras},
  doi          = {10.1016/S0168-0072(02)00096-9},
  number       = {1-3},
  pages        = {1--47},
  volume       = {124},
  priority     = {prio3},
}

@Thesis{McBride1999,
  author      = {McBride, Conor},
  date        = {1999},
  institution = {University of Edinburgh},
  title       = {Dependently typed functional programs and their proofs},
  type        = {phdthesis},
  file        = {:McBride1999 - Dependently Typed Functional Programs and Their Proofs.pdf:PDF},
  priority    = {prio3},
}

@InProceedings{Altenkirch2007,
  author    = {Altenkirch, Thorsten and McBride, Conor and Swierstra, Wouter},
  booktitle = {Proceedings of the 2007 Workshop on Programming Languages Meets Program Verification},
  date      = {2007},
  title     = {Observational Equality, Now!},
  doi       = {10.1145/1292597.1292608},
  isbn      = {9781595936776},
  location  = {Freiburg, Germany},
  pages     = {57–68},
  publisher = {Association for Computing Machinery},
  series    = {PLPV '07},
  abstract  = {This paper has something new and positive to say about propositional equality in programming and proof systems based on the Curry-Howard correspondence between propositions and types. We have found a way to present a propositional equality type which is substitutive, allowing us to reason by replacing equal for equal in propositions;which reflects the observable behaviour of values rather than their construction: in particular, we have extensionality-- functions are equal if they take equal inputs to equal outputs;which retains strong normalisation, decidable typechecking and canonicity--the property that closed normal forms inhabiting datatypes have canonical constructors; which allows inductive data structures to be expressed in terms of a standard characterisation of well-founded trees;which is presented syntactically--you can implement it directly, and we are doing so this approach stands at the core of Epigram 2;which you can play with now: we have simulated our system by a shallow embedding in Agda 2, shipping as part of the standard examples package for that system [21]..Until now, it has always been necessary to sacrifice some of these aspects. The closest attempt in the literature is Altenkirch's construction of a setoid-model for a system with canonicity and extensionality on top of an intensional type theory with proof-irrelevant propositions [4]. Our new proposal simplifies Altenkirch's construction by adopting McBride's heterogeneous approach to equality [19].},
  address   = {New York, NY, USA},
  keywords  = {equality, type theory},
  numpages  = {12},
  priority  = {prio3},
}

@Article{Blanchette2016,
  author       = {Blanchette, Jasmin C. and Kaliszyk, Cezary and Paulson, Lawrence C. and Urban, Josef},
  date         = {2016-01},
  journaltitle = {Journal of Formalized Reasoning},
  title        = {Hammering towards QED},
  doi          = {10.6092/issn.1972-5787/4593},
  number       = {1},
  pages        = {101–148},
  url          = {https://jfr.unibo.it/article/view/4593},
  volume       = {9},
  abstractnote = {This paper surveys the emerging methods to automate reasoning over large libraries developed with formal proof assistants. We call these methods hammers. They give the authors of formal proofs a strong &amp;quot;one-stroke&amp;quot; tool for discharging difficult lemmas without the need for careful and detailed manual programming of proof search.The main ingredients underlying this approach are efficient automatic theorem provers that can cope with hundreds of axioms, suitable translations of richer logics to their formalisms, heuristic and learning methods that select relevant facts from large libraries, and methods that reconstruct the automatically found proofs inside the proof assistants.We outline the history of these methods, explain the main issues and techniques, and show their strength on several large benchmarks. We also discuss the relation of this technology to the QED Manifesto and consider its implications for QED-style efforts.},
  priority     = {prio3},
}

@Article{Immler2018,
  author       = {Immler, Fabian},
  date         = {2018},
  journaltitle = {Journal of Automated Reasoning},
  title        = {A Verified ODE Solver and the Lorenz Attractor},
  doi          = {10.1007/s10817-017-9448-y},
  issn         = {1573-0670},
  number       = {1},
  pages        = {73--111},
  url          = {https://doi.org/10.1007/s10817-017-9448-y},
  volume       = {61},
  abstract     = {A rigorous numerical algorithm, formally verified with Isabelle/HOL, is used to certify the computations that Tucker used to prove chaos for the Lorenz attractor. The verification is based on a formalization of a diverse variety of mathematics and algorithms. Formalized mathematics include ordinary differential equations and Poincaré maps. Algorithms include low level approximation schemes based on Runge-Kutta methods and affine arithmetic. On a high level, reachability analysis is guided by static hybridization and adaptive step-size control and splitting. The algorithms are systematically refined towards an implementation that can be executed on Tucker’s original input data.},
  priority     = {prio3},
  refid        = {Immler2018},
}

@InProceedings{Bhargavan2017,
  author     = {Karthikeyan Bhargavan and Barry Bond and Antoine Delignat-Lavaud and C{\'e}dric Fournet and Chris Hawblitzel and Catalin Hritcu and Samin Ishtiaq and Markulf Kohlweiss and Rustan Leino and Jay Lorch and Kenji Maillard and Jianyang Pan and Bryan Parno and Jonathan Protzenko and Tahina Ramananandro and Ashay Rane and Aseem Rastogi and Nikhil Swamy and Laure Thompson and Peng Wang and Santiago Zanella-B{\'e}guelin and Jean-Karim Zinzindohou{\'e}},
  booktitle  = {2nd Summit on Advances in Programming Languages (SNAPL 2017)},
  date       = {2017},
  title      = {{Everest: Towards a Verified, Drop-in Replacement of HTTPS}},
  doi        = {10.4230/LIPIcs.SNAPL.2017.1},
  editor     = {Benjamin S. Lerner and Rastislav Bod{\'i}k and Shriram Krishnamurthi},
  isbn       = {978-3-95977-032-3},
  location   = {Dagstuhl, Germany},
  pages      = {1:1--1:12},
  publisher  = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  series     = {Leibniz International Proceedings in Informatics (LIPIcs)},
  url        = {http://drops.dagstuhl.de/opus/volltexte/2017/7119},
  volume     = {71},
  annotation = {Keywords: Security, Cryptography, Verification, TLS},
  issn       = {1868-8969},
  priority   = {prio3},
  urn        = {urn:nbn:de:0030-drops-71196},
}

@Article{Mahboubi2019,
  author              = {Mahboubi, Assia and Melquiond, Guillaume and Sibut-Pinote, Thomas},
  title               = {{Formally Verified Approximations of Definite Integrals}},
  doi                 = {10.1007/s10817-018-9463-7},
  number              = {2},
  pages               = {281-300},
  url                 = {https://hal.inria.fr/hal-01630143},
  volume              = {62},
  hal_id              = {hal-01630143},
  hal_local_reference = {ACL+},
  hal_version         = {v2},
  journal             = {{Journal of Automated Reasoning}},
  keywords            = {numeric computations ; formal proof ; Improper integrals ; definite integrals ; decision procedure ; real analysis ; polynomial approximations ; interval arithmetic},
  month               = Feb,
  pdf                 = {https://hal.inria.fr/hal-01630143v2/file/main.pdf},
  priority            = {prio3},
  publisher           = {{Springer Verlag}},
  year                = {2019},
}

@Comment{jabref-meta: databaseType:biblatex;}

@Comment{jabref-meta: grouping:
0 AllEntriesGroup:;
1 StaticGroup:Bidirectional Typing\;0\;0\;0x8a8a8aff\;\;\;;
1 StaticGroup:Category Theory\;0\;0\;0x8a8a8aff\;\;\;;
1 StaticGroup:CIC\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:Universes\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:Inductive Types\;0\;0\;0x8a8a8aff\;\;\;;
2 StaticGroup:Cumulativity\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:Irrelevance\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Textbooks\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:Computer Science Textbooks\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:Mathematics Textbooks\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Constructivism\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Effects\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Gradual Typing\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:HoTT\;0\;0\;0x8a8a8aff\;\;\;;
1 StaticGroup:Lambda Calculus\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Logic\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:Topoi\;0\;0\;0x8a8a8aff\;\;\;;
2 StaticGroup:Linear Logic\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Manuals\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Models of TT\;2\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:Syntactical Models\;2\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Popularization\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Proof Assistants\;0\;0\;0x8a8a8aff\;\;\;;
1 StaticGroup:Semantics of PL\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Topology\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Pure Type Systems\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Conversion\;0\;0\;0x8a8a8aff\;\;\;;
2 StaticGroup:Eta law\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:MLTT\;0\;0\;0x8a8a8aff\;\;\;;
1 StaticGroup:Normalization\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:Normalization by evaluation\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Formalization\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:MetaCoq\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:Dependent types\;0\;1\;0x8a8a8aff\;\;\;;
1 StaticGroup:History\;0\;1\;0x8a8a8aff\;\;\;;
}
